#!/usr/bin/env bash
# dx-triage-cron
# Periodic repo state checker that creates triage flag files
#
# Runs via cron (HOURLY) to check if repos need attention.
# Creates:
#   - .git/DX_TRIAGE_STATUS (always, hourly update)
#   - .git/DX_TRIAGE_REQUIRED (when critical issues detected)
#
# This is the CRON component of the dx-triage enforcement system.
# The pre-push hook enforces ACK must be newer than STATUS.
#
# Usage (via cron):
#   0 * * * * /home/feng/.local/bin/dx-triage-cron >/dev/null 2>&1
#
# Manual testing:
#   dx-triage-cron --dry-run  # Show what would be flagged
#   dx-triage-cron --verbose   # Show detailed output

set -euo pipefail

# Resolve symlinks to get actual script directory
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# shellcheck disable=SC1090
source "$SCRIPT_DIR/canonical-targets.sh" 2>/dev/null || true

CANONICAL_TRUNK_BRANCH="${CANONICAL_TRUNK_BRANCH:-main}"

# Parse args
DRY_RUN=""
VERBOSE=""
for arg in "$@"; do
    case "$arg" in
        --dry-run) DRY_RUN="echo" ;;
        --verbose|-v) VERBOSE="1" ;;
        --help|-h)
            echo "dx-triage-cron - Periodic repo state checker"
            echo ""
            echo "Usage:"
            echo "  dx-triage-cron [--dry-run] [--verbose]"
            echo ""
            echo "This script checks canonical repos for drift conditions:"
            echo "  - Feature branches with no commits for >24h"
            echo "  - Behind origin/\$CANONICAL_TRUNK_BRANCH by >100 commits"
            echo "  - Feature branches already merged in remote"
            echo "  - Uncommitted changes not touched in >48h"
            echo ""
            echo "If drift detected, creates .git/DX_TRIAGE_REQUIRED with details."
            echo ""
            exit 0
            ;;
    esac
done

log() {
    if [[ -n "$VERBOSE" ]]; then
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2
    fi
}

# Collect all repos to check
ALL_REPOS=()
if declare -p CANONICAL_REQUIRED_REPOS >/dev/null 2>&1; then
    ALL_REPOS+=("${CANONICAL_REQUIRED_REPOS[@]}")
fi
if declare -p CANONICAL_OPTIONAL_REPOS >/dev/null 2>&1; then
    ALL_REPOS+=("${CANONICAL_OPTIONAL_REPOS[@]}")
fi

if [[ ${#ALL_REPOS[@]} -eq 0 ]]; then
    log "No canonical repos defined, exiting"
    exit 0
fi

# Process each repo
FLAGGED_COUNT=0

for repo in "${ALL_REPOS[@]}"; do
    repo_path="$HOME/$repo"

    # Skip if repo doesn't exist
    if [[ ! -d "$repo_path/.git" ]]; then
        log "Skipping $repo (not found)"
        continue
    fi

    cd "$repo_path"

    # Skip worktrees (only process main repo)
    if [[ "$(git rev-parse --git-dir)" != "$(git rev-parse --git-common-dir)" ]]; then
        log "Skipping $repo (worktree)"
        continue
    fi

    log "Checking $repo..."

    # Fetch to get accurate state
    git fetch origin --quiet 2>/dev/null || true

    # Get current state
    branch="$(git branch --show-current 2>/dev/null || echo "unknown")"
    dirty_count=$(git status --porcelain=v1 2>/dev/null | wc -l | tr -d ' ')

    # Get last commit time (in hours ago)
    last_commit_secs=$(git log -1 --format='%ct' 2>/dev/null || echo "0")
    current_secs=$(date +%s)
    hours_since_commit=$(( (current_secs - last_commit_secs) / 3600 ))

    # Get last file modification time (for uncommitted changes)
    # Cross-platform stat: macOS (BSD) uses -f %m, Linux (GNU) uses -c %Y
    last_file_change=0
    hours_since_change=0
    if [[ "$dirty_count" -gt 0 ]]; then
        # Get both modified and untracked files, handling filenames with spaces
        while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            [[ ! -f "$f" ]] && continue
            # Try GNU stat first (Linux), then BSD stat (macOS)
            f_time=0
            f_time=$(stat -c %Y "$f" 2>/dev/null) || f_time=$(stat -f %m "$f" 2>/dev/null) || f_time=0
            if [[ -n "$f_time" ]] && [[ "$f_time" -gt "$last_file_change" ]]; then
                last_file_change="$f_time"
            fi
        done < <(git diff --name-only 2>/dev/null; git ls-files --others --exclude-standard 2>/dev/null)
        hours_since_change=$(( (current_secs - last_file_change) / 3600 ))
    fi

    # Check behind/ahead
    behind=0
    if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
        behind=$(git rev-list --count "HEAD..origin/$branch" 2>/dev/null || echo 0)
    elif [[ "$branch" != "$CANONICAL_TRUNK_BRANCH" ]]; then
        if git rev-parse --verify "origin/$CANONICAL_TRUNK_BRANCH" >/dev/null 2>&1; then
            behind=$(git rev-list --count "HEAD..origin/$CANONICAL_TRUNK_BRANCH" 2>/dev/null || echo 0)
        fi
    fi

    # Check if feature branch is merged
    merged=0
    if [[ "$branch" != "$CANONICAL_TRUNK_BRANCH" ]]; then
        if git merge-base --is-ancestor HEAD "origin/$CANONICAL_TRUNK_BRANCH" 2>/dev/null; then
            merged=1
        fi
    fi

    # Determine if flagging is needed
    FLAG_REASON=""
    RECOMMENDATION=""

    if [[ "$merged" -eq 1 ]]; then
        FLAG_REASON="Feature branch '$branch' appears merged in origin/$CANONICAL_TRUNK_BRANCH"
        RECOMMENDATION="Safe to reset: git checkout $CANONICAL_TRUNK_BRANCH && git pull"
    elif [[ "$branch" != "$CANONICAL_TRUNK_BRANCH" && "$hours_since_commit" -gt 24 ]]; then
        FLAG_REASON="On feature branch '$branch' with no commits for ${hours_since_commit}h"
        RECOMMENDATION="Finish work or reset if abandoned"
    elif [[ "$behind" -gt 100 ]]; then
        FLAG_REASON="Behind origin/$CANONICAL_TRUNK_BRANCH by $behind commits"
        RECOMMENDATION="Safe to pull: git pull"
    elif [[ "$dirty_count" -gt 0 && "$hours_since_change" -gt 48 ]]; then
        FLAG_REASON="Uncommitted changes not touched in ${hours_since_change}h"
        RECOMMENDATION="Commit or stash changes"
    fi

    triage_file=".git/DX_TRIAGE_REQUIRED"
    status_file=".git/DX_TRIAGE_STATUS"

    # Get last commit author (for both files)
    last_author=$(git log -1 --format='%an <%ae>' 2>/dev/null || echo "unknown")

    # Generate state fingerprint (without timestamp) for ACK gating
    state_fingerprint="BRANCH:$branch|STATE:$([[ "$merged" -eq 1 ]] && echo "MERGED" || [[ "$branch" == "$CANONICAL_TRUNK_BRANCH" ]] && echo "TRUNK" || echo "FEATURE")|DIRTY:$dirty_count|BEHIND:$behind|ISSUES:$([[ -n "$FLAG_REASON" ]] && echo "1" || echo "0")"

    # Check if state actually changed (compare fingerprint with stored one)
    stored_fingerprint=""
    fingerprint_changed="false"
    if [[ -f "$status_file" ]]; then
        stored_fingerprint=$(grep "^X_FINGERPRINT:" "$status_file" 2>/dev/null | cut -d':' -f2-)
    fi

    if [[ "$state_fingerprint" != "$stored_fingerprint" ]]; then
        fingerprint_changed="true"
    fi

    # ALWAYS write STATUS (for fresh timestamps), but log when fingerprint changed
    cat > "$status_file" <<EOF
STATUS_AT: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
X_FINGERPRINT: $state_fingerprint
BRANCH: $branch
STATE: $([[ "$merged" -eq 1 ]] && echo "MERGED" || [[ "$branch" == "$CANONICAL_TRUNK_BRANCH" ]] && echo "TRUNK" || echo "FEATURE")
DIRTY: $dirty_count uncommitted files
BEHIND: $behind commits behind origin/$CANONICAL_TRUNK_BRANCH

Last commit: ${hours_since_commit}h ago by $last_author
$([[ "$hours_since_change" -gt 0 ]] && echo "Last change: ${hours_since_change}h ago" || echo "")

Current issues:
$([[ -n "$FLAG_REASON" ]] && echo "  - $FLAG_REASON" || echo "  None")
EOF

    if [[ "$fingerprint_changed" == "true" ]]; then
        log "STATUS: $repo - $branch, $dirty_count dirty, $behind behind (fingerprint changed)"
    else
        log "STATUS: $repo - $branch, $dirty_count dirty, $behind behind (timestamp updated)"
    fi

    # Write or remove critical flag file (only for issues requiring action)
    if [[ -n "$FLAG_REASON" ]]; then
        # Create DX_TRIAGE_REQUIRED file
        cat > "$triage_file" <<EOF
FLAGGED_AT: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
BRANCH: $branch
REASON: $FLAG_REASON
BEHIND: $behind commits behind origin/$CANONICAL_TRUNK_BRANCH

Last commit: ${hours_since_commit}h ago by $last_author

Recommended action:
  dx-triage              # See full status of all repos
  dx-triage --fix        # Apply safe fixes and clear flag
  dx-triage --ack        # Acknowledge and clear flag (I know what I'm doing)

To investigate manually:
  git status
  git log --oneline -5
  git branch -r --contains HEAD
EOF

        log "FLAGGED: $repo - $FLAG_REASON"
        FLAGGED_COUNT=$((FLAGGED_COUNT + 1))
    else
        # Remove flag file if state is now clean
        if [[ -f "$triage_file" ]]; then
            $DRY_RUN rm -f "$triage_file"
            log "CLEARED: $repo - state is now healthy"
        fi
    fi
done

log "dx-triage-cron complete: $FLAGGED_COUNT repo(s) flagged"

exit 0
