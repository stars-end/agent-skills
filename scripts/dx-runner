#!/usr/bin/env bash
set -euo pipefail

# dx-runner (V2.0 - Unified Multi-Provider Dispatch Runner with Hardening)
#
# Canonical entrypoint for all agent dispatch with unified governance:
#   - Profile-first starts with pinned provider/model/strictness (bd-8wdg.1)
#   - Model drift blocking unless explicit override (bd-8wdg.2)
#   - Deterministic outcome semantics (bd-8wdg.3)
#   - Profile-based strict preflight (bd-8wdg.4)
#   - Scope guardrails (bd-8wdg.5)
#   - Evidence truthfulness gates (bd-8wdg.6)
#   - Preflight checks (auth, model, backend)
#   - Permission gates (worktree-only policy)
#   - No-op heartbeat detection
#   - Baseline/integrity/feature-key gates
#   - Failure taxonomy with deterministic codes
#   - Startup-aware health states (bd-8wdg.10)
#   - Auto mise trust remediation (bd-8wdg.11)
#
# Providers:
#   cc-glm    - Claude via Z.ai (reliability backstop)
#   opencode  - OpenCode headless (primary throughput)
#   gemini    - Gemini CLI (parallel capacity)
#
# Commands:
#   start        --beads <id> --provider <name> --prompt-file <path> [options]
#   start        --beads <id> --profile <name> --prompt-file <path> [options]
#   status       [--beads <id>] [--json]
#   check        --beads <id> [--stall-minutes <n>] [--json]
#   health       [--beads <id>] [--json]
#   restart      --beads <id>
#   stop         --beads <id>
#   watchdog     [--interval <sec>] [--max-retries <n>]
#   report       --beads <id> [--format json|markdown]
#   preflight    [--provider <name>] [--profile <name>]
#   probe        --provider <name> --model <id>
#   profiles     [--list] [--show <name>]
#   baseline-gate [--beads <id> | --worktree <path>] --required-baseline <sha>
#   integrity-gate [--beads <id> | --worktree <path>] --reported-commit <sha>
#   feature-key-gate [--beads <id> | --worktree <path>] --feature-key <bd-id>
#   evidence-gate --beads <id> --signoff-file <path>
#   scope-gate   --beads <id> --allowed-paths-file <path> [--mutation-budget <n>]
#
# Exit Codes:
#   0  - Success
#   1  - General error
#   2  - Job stalled
#   3  - Job exited with error
#   10 - Auth resolution failed
#   11 - Token file error
#   20 - Provider not found
#   21 - Preflight failed
#   22 - Permission denied (non-worktree path)
#   23 - No-op detected
#   24 - Beads gate failed
#   25 - Model unavailable
#   26 - Provider concurrency cap exceeded
#   27 - Provider execution mode unsupported/misconfigured
#   28 - Model override blocked (drift protection)
#   29 - Scope guard violation
#   30 - Evidence gate failed

RUNNER_VERSION="2.0.0"
# Resolve symlink to get actual script directory
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
if [[ -L "$SCRIPT_SOURCE" ]]; then
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"
ADAPTERS_DIR="${SCRIPT_DIR}/adapters"
PROFILES_DIR="${SCRIPT_DIR}/../configs/dx-runner-profiles"

# Default log directory (provider-specific subdirs)
LOG_DIR="/tmp/dx-runner"

# Provider configuration
declare -A PROVIDER_DEFAULT_MODEL=(
    ["cc-glm"]="glm-5"
    ["opencode"]="zhipuai-coding-plan/glm-5"
    ["gemini"]="gemini-3-flash-preview"
)

declare -A PROVIDER_FALLBACK_CHAIN=(
    ["opencode"]="zhipuai-coding-plan/glm-5"
)

# bd-8wdg.10: Startup-aware health thresholds
STARTUP_FIRST_OUTPUT_GRACE_SEC="${DX_RUNNER_STARTUP_GRACE_SEC:-300}"
STARTUP_FIRST_MUTATION_GRACE_SEC="${DX_RUNNER_STARTUP_MUTATION_GRACE_SEC:-600}"

CMD="${1:-}"
shift || true

# ============================================================================
# UTILITIES (Proven from cc-glm-job.sh)
# ============================================================================

now_utc() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

host_short() {
    hostname 2>/dev/null | cut -d. -f1
}

parse_utc_epoch() {
    local ts="${1:-}"
    [[ -n "$ts" ]] || return 1
    date -d "$ts" +%s 2>/dev/null \
        || date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$ts" +%s 2>/dev/null \
        || return 1
}

file_mtime_epoch() {
    local f="$1"
    if stat -f "%m" "$f" >/dev/null 2>&1; then
        stat -f "%m" "$f"
        return 0
    fi
    stat -c "%Y" "$f"
}

format_elapsed() {
    local sec="$1"
    if [[ "$sec" -lt 60 ]]; then
        printf "%ss" "$sec"
        return 0
    fi
    local min=$((sec / 60))
    local rem=$((sec % 60))
    if [[ "$min" -lt 60 ]]; then
        printf "%sm%ss" "$min" "$rem"
        return 0
    fi
    local hr=$((min / 60))
    local min_rem=$((min % 60))
    printf "%sh%sm" "$hr" "$min_rem"
}

json_escape() {
    local s="${1:-}"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\n'/\\n}"
    s="${s//$'\r'/\\r}"
    s="${s//$'\t'/\\t}"
    printf '%s' "$s"
}

join_by() {
    local delim="$1"
    shift || true
    local out="" first=true
    local item
    for item in "$@"; do
        if [[ "$first" == "true" ]]; then
            out="$item"
            first=false
        else
            out="${out}${delim}${item}"
        fi
    done
    printf '%s' "$out"
}

valid_feature_key() {
    local fk="$1"
    [[ "$fk" =~ ^bd-[a-z0-9]+(\.[a-z0-9]+)*$ ]]
}

is_truthy() {
    local v="${1:-}"
    [[ "$v" == "1" || "$v" == "true" || "$v" == "TRUE" || "$v" == "yes" || "$v" == "YES" ]]
}

requires_railway_auth() {
    local provider="$1"
    is_truthy "${REQUIRE_RAILWAY_AUTH:-${DX_RUNNER_REQUIRE_RAILWAY_AUTH:-0}}"
}

railway_auth_gate() {
    local provider="${1:-}"
    if ! requires_railway_auth "$provider"; then
        echo "railway auth requirement: SKIP (provider=$provider)"
        return 0
    fi

    echo -n "railway auth capability: "
    if ! command -v railway >/dev/null 2>&1; then
        echo "MISSING_CLI"
        echo "  ERROR_CODE=railway_cli_missing severity=error action=install_railway_cli"
        return 1
    fi

    local has_token=false has_service_ctx=false whoami_ok=false
    [[ -n "${RAILWAY_TOKEN:-}" ]] && has_token=true
    [[ -n "${RAILWAY_SERVICE_FRONTEND_URL:-}" || -n "${RAILWAY_SERVICE_BACKEND_URL:-}" ]] && has_service_ctx=true
    if railway whoami >/dev/null 2>&1; then
        whoami_ok=true
    fi

    if [[ "$has_token" == "true" || "$whoami_ok" == "true" ]] && [[ "$has_service_ctx" == "true" ]]; then
        echo "OK (token/auth + service context present)"
        return 0
    fi

    echo "MISSING_CONTEXT"
    if [[ "$has_service_ctx" != "true" ]]; then
        echo "  ERROR_CODE=railway_service_context_missing severity=error action=run_in_railway_shell_or_export_service_urls"
    fi
    if [[ "$has_token" != "true" && "$whoami_ok" != "true" ]]; then
        echo "  ERROR_CODE=railway_auth_missing severity=error action=railway_login_or_export_RAILWAY_TOKEN"
    fi
    return 1
}

provider_max_parallel() {
    local provider="$1"
    case "$provider" in
        opencode) echo "${DX_RUNNER_MAX_PARALLEL_OPENCODE:-2}" ;;
        cc-glm) echo "${DX_RUNNER_MAX_PARALLEL_CC_GLM:-2}" ;;
        gemini) echo "${DX_RUNNER_MAX_PARALLEL_GEMINI:-1}" ;;
        *) echo "${DX_RUNNER_MAX_PARALLEL_DEFAULT:-2}" ;;
    esac
}

provider_running_count() {
    local provider="$1"
    local count=0
    shopt -s nullglob
    for pidf in "/tmp/dx-runner/${provider}"/*.pid; do
        [[ -f "$pidf" ]] || continue
        local beads pid
        beads="$(basename "$pidf" .pid)"
        [[ "$beads" == *.monitor ]] && continue
        pid="$(cat "$pidf" 2>/dev/null || true)"
        if [[ "$pid" =~ ^[0-9]+$ ]] && ps -p "$pid" >/dev/null 2>&1; then
            count=$((count + 1))
        fi
    done
    echo "$count"
}

strip_ansi() {
    sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' 2>/dev/null || cat
}

meta_get() {
    local meta="$1"
    local key="$2"
    awk -F= -v key="$key" '$1==key {print substr($0, length(key)+2); exit}' "$meta" 2>/dev/null || true
}

meta_set() {
    local meta="$1"
    local key="$2"
    local val="$3"
    local tmp
    tmp="$(mktemp)"
    if [[ -f "$meta" ]]; then
        awk -F= -v key="$key" '$1!=key {print $0}' "$meta" > "$tmp"
    fi
    printf "%s=%s\n" "$key" "$val" >> "$tmp"
    mv "$tmp" "$meta"
}

# ============================================================================
# PROFILE SYSTEM (bd-8wdg.1)
# ============================================================================

# Default profile configuration
declare -A PROFILE_CONFIG=()
declare -A PROFILE_PREFLIGHT_POLICY=()
PROFILE_NAME=""
PROFILE_STRICT=false

load_profile() {
    local profile_name="$1"
    local profile_file=""
    
    # Search for profile in order of precedence
    for search_dir in "$PROFILES_DIR" "$SCRIPT_DIR/profiles" "/etc/dx-runner/profiles" "$HOME/.config/dx-runner/profiles"; do
        if [[ -f "${search_dir}/${profile_name}.yaml" ]]; then
            profile_file="${search_dir}/${profile_name}.yaml"
            break
        fi
    done
    
    if [[ -z "$profile_file" ]]; then
        echo "ERROR: Profile '$profile_name' not found" >&2
        echo "reason_code=profile_not_found" >&2
        return 1
    fi
    
    # Parse YAML profile (simple key extraction)
    PROFILE_NAME="$profile_name"
    PROFILE_CONFIG["name"]="$profile_name"
    
    # Extract provider settings
    local provider_block=false
    local preflight_block=false
    local policy_block=false
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Detect sections
        if [[ "$line" =~ ^provider: ]]; then
            provider_block=true
            preflight_block=false
            policy_block=false
            continue
        elif [[ "$line" =~ ^preflight: ]]; then
            preflight_block=true
            provider_block=false
            policy_block=false
            continue
        elif [[ "$line" =~ ^[[:space:]]*policy: ]] && [[ "$preflight_block" == true ]]; then
            policy_block=true
            continue
        elif [[ "$line" =~ ^[a-z]+: ]] && [[ "$provider_block" == true ]] && [[ ! "$line" =~ ^[[:space:]] ]]; then
            provider_block=false
        elif [[ "$line" =~ ^[a-z]+: ]] && [[ "$preflight_block" == true ]] && [[ ! "$line" =~ ^[[:space:]] ]]; then
            preflight_block=false
            policy_block=false
        fi
        
        # Extract key-value pairs
        if [[ "$line" =~ ^[[:space:]]*([a-z_]+):[[:space:]]*(.+)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]//\"/}"
            value="${value//\'/}"
            
            # bd-8wdg.4: Parse preflight.policy entries
            if [[ "$policy_block" == true ]]; then
                PROFILE_PREFLIGHT_POLICY["$key"]="$value"
            fi
            
            case "$key" in
                name|model|allow_model_override|execution_mode|fallback_provider)
                    PROFILE_CONFIG["provider_$key"]="$value"
                    ;;
                max_parallel|queue_timeout_sec)
                    PROFILE_CONFIG["concurrency_$key"]="$value"
                    ;;
                strict)
                    PROFILE_CONFIG["preflight_$key"]="$value"
                    if [[ "$value" == "true" ]]; then
                        PROFILE_STRICT=true
                    fi
                    ;;
                max_runtime_minutes|no_mutation_timeout_minutes|stall_minutes|first_output_grace_seconds|first_mutation_grace_seconds)
                    PROFILE_CONFIG["timeouts_$key"]="$value"
                    ;;
                enforce_allowed_paths|allowed_paths_file|mutation_budget|file_budget)
                    PROFILE_CONFIG["scope_$key"]="$value"
                    ;;
            esac
        fi
    done < "$profile_file"
    
    # Apply profile settings to environment
    if [[ -n "${PROFILE_CONFIG[provider_name]:-}" ]]; then
        PROVIDER="${PROFILE_CONFIG[provider_name]}"
    fi
    if [[ -n "${PROFILE_CONFIG[provider_model]:-}" ]]; then
        export OPENCODE_MODEL="${PROFILE_CONFIG[provider_model]}"
    fi
    if [[ "${PROFILE_CONFIG[provider_allow_model_override]:-false}" == "true" ]]; then
        export DX_RUNNER_ALLOW_MODEL_OVERRIDE=1
    fi
    if [[ -n "${PROFILE_CONFIG[concurrency_max_parallel]:-}" ]]; then
        case "${PROFILE_CONFIG[provider_name]:-}" in
            opencode) export DX_RUNNER_MAX_PARALLEL_OPENCODE="${PROFILE_CONFIG[concurrency_max_parallel]}" ;;
            cc-glm) export DX_RUNNER_MAX_PARALLEL_CC_GLM="${PROFILE_CONFIG[concurrency_max_parallel]}" ;;
            gemini) export DX_RUNNER_MAX_PARALLEL_GEMINI="${PROFILE_CONFIG[concurrency_max_parallel]}" ;;
        esac
    fi
    if [[ -n "${PROFILE_CONFIG[timeouts_max_runtime_minutes]:-}" ]]; then
        MAX_RUNTIME_MINUTES="${PROFILE_CONFIG[timeouts_max_runtime_minutes]}"
    fi
    if [[ -n "${PROFILE_CONFIG[timeouts_no_mutation_timeout_minutes]:-}" ]]; then
        NO_MUTATION_TIMEOUT_MINUTES="${PROFILE_CONFIG[timeouts_no_mutation_timeout_minutes]}"
    fi
    if [[ -n "${PROFILE_CONFIG[timeouts_stall_minutes]:-}" ]]; then
        STALL_MINUTES="${PROFILE_CONFIG[timeouts_stall_minutes]}"
    fi
    if [[ -n "${PROFILE_CONFIG[timeouts_first_output_grace_seconds]:-}" ]]; then
        STARTUP_FIRST_OUTPUT_GRACE_SEC="${PROFILE_CONFIG[timeouts_first_output_grace_seconds]}"
    fi
    if [[ -n "${PROFILE_CONFIG[timeouts_first_mutation_grace_seconds]:-}" ]]; then
        STARTUP_FIRST_MUTATION_GRACE_SEC="${PROFILE_CONFIG[timeouts_first_mutation_grace_seconds]}"
    fi
    
    echo "profile_loaded=$profile_name"
    echo "profile_file=$profile_file"
    return 0
}

profile_get_preflight_policy() {
    local check_code="$1"
    local default="${2:-warn}"
    
    # bd-8wdg.4: Check profile-specific policy first
    if [[ -n "${PROFILE_PREFLIGHT_POLICY[$check_code]:-}" ]]; then
        echo "${PROFILE_PREFLIGHT_POLICY[$check_code]}"
        return 0
    fi
    
    # In strict mode, escalate critical warnings to errors
    if [[ "$PROFILE_STRICT" == true ]]; then
        case "$check_code" in
            opencode_binary_missing|model_unavailable|auth_or_quota_blocked|worktree_missing|canonical_model_probe_timeout|mise_untrusted)
                echo "error"
                return 0
                ;;
        esac
    fi
    echo "$default"
}

# bd-8wdg.4: Helper for adapters to report check result based on profile policy
# Usage: preflight_report_check <check_code> <status> <message> <error_var> <warn_var>
# Returns: 0 if warning, 1 if error (for caller to increment counter)
preflight_report_check() {
    local check_code="$1"
    local status="$2"  # ok, missing, failed, timeout, etc.
    local message="$3"
    local error_var="$4"
    local warn_var="$5"
    
    if [[ "$status" == "ok" ]]; then
        echo "OK ($message)"
        return 0
    fi
    
    local policy
    policy="$(profile_get_preflight_policy "$check_code" "warn")"
    
    if [[ "$policy" == "error" ]]; then
        echo "$status"
        echo "  ERROR: $message"
        echo "  ERROR_CODE=${check_code} severity=error"
        if [[ -n "$error_var" ]]; then
            eval "$error_var=\$(($error_var + 1))"
        fi
        return 1
    else
        echo "$status"
        echo "  WARN: $message"
        echo "  WARN_CODE=${check_code} severity=warn"
        if [[ -n "$warn_var" ]]; then
            eval "$warn_var=\$(($warn_var + 1))"
        fi
        return 0
    fi
}

list_profiles() {
    local found=0
    for search_dir in "$PROFILES_DIR" "$SCRIPT_DIR/profiles" "/etc/dx-runner/profiles" "$HOME/.config/dx-runner/profiles"; do
        if [[ -d "$search_dir" ]]; then
            for f in "$search_dir"/*.yaml; do
                [[ -f "$f" ]] || continue
                local name
                name="$(basename "$f" .yaml)"
                echo "$name"
                found=$((found + 1))
            done
        fi
    done
    return $([[ $found -gt 0 ]] && echo 0 || echo 1)
}

show_profile() {
    local profile_name="$1"
    local profile_file=""
    
    for search_dir in "$PROFILES_DIR" "$SCRIPT_DIR/profiles"; do
        if [[ -f "${search_dir}/${profile_name}.yaml" ]]; then
            profile_file="${search_dir}/${profile_name}.yaml"
            break
        fi
    done
    
    if [[ -z "$profile_file" ]]; then
        echo "Profile '$profile_name' not found" >&2
        return 1
    fi
    
    cat "$profile_file"
}

# ============================================================================
# JOB PATHS (Provider-aware)
# ============================================================================

job_paths() {
    local beads="$1"
    local provider="${2:-}"
    
    if [[ -n "$provider" ]]; then
        LOG_DIR="/tmp/dx-runner/${provider}"
    else
        # Try to detect provider from meta (search all provider dirs)
        provider="$(find_provider_for_beads "$beads")"
        if [[ -n "$provider" ]]; then
            LOG_DIR="/tmp/dx-runner/${provider}"
        else
            LOG_DIR="/tmp/dx-runner"
        fi
    fi
    
    mkdir -p "$LOG_DIR"
    
    PID_FILE="${LOG_DIR}/${beads}.pid"
    LOG_FILE="${LOG_DIR}/${beads}.log"
    META_FILE="${LOG_DIR}/${beads}.meta"
    OUTCOME_FILE="${LOG_DIR}/${beads}.outcome"
    RC_FILE="${LOG_DIR}/${beads}.rc"
    CONTRACT_FILE="${LOG_DIR}/${beads}.contract"
    MUTATION_FILE="${LOG_DIR}/${beads}.mutation"
    HEARTBEAT_FILE="${LOG_DIR}/${beads}.heartbeat"
    MONITOR_PID_FILE="${LOG_DIR}/${beads}.monitor.pid"
}

# P1 fix: Search all provider directories to find beads metadata
find_provider_for_beads() {
    local beads="$1"

    # First check root dir metadata for backward compatibility.
    if [[ -f "/tmp/dx-runner/${beads}.meta" ]]; then
        meta_get "/tmp/dx-runner/${beads}.meta" "provider" 2>/dev/null || true
        return 0
    fi

    # Resolve to the latest provider instance for this beads id.
    # Use the newest artifact among meta/outcome/pid per provider to avoid
    # stale selection after provider switches.
    local latest_provider=""
    local latest_epoch=0
    shopt -s nullglob
    for dir in /tmp/dx-runner/*/; do
        [[ -d "$dir" ]] || continue
        local provider meta_file outcome_file pid_file candidate_epoch meta_epoch outcome_epoch pid_epoch
        provider="$(basename "$dir")"
        meta_file="${dir}${beads}.meta"
        outcome_file="${dir}${beads}.outcome"
        pid_file="${dir}${beads}.pid"
        [[ -f "$meta_file" || -f "$outcome_file" || -f "$pid_file" ]] || continue

        candidate_epoch=0
        meta_epoch=0
        outcome_epoch=0
        pid_epoch=0
        if [[ -f "$meta_file" ]]; then
            meta_epoch="$(file_mtime_epoch "$meta_file" 2>/dev/null || echo 0)"
        fi
        if [[ -f "$outcome_file" ]]; then
            outcome_epoch="$(file_mtime_epoch "$outcome_file" 2>/dev/null || echo 0)"
        fi
        if [[ -f "$pid_file" ]]; then
            pid_epoch="$(file_mtime_epoch "$pid_file" 2>/dev/null || echo 0)"
        fi

        if [[ "$meta_epoch" -gt "$candidate_epoch" ]]; then
            candidate_epoch="$meta_epoch"
        fi
        if [[ "$outcome_epoch" -gt "$candidate_epoch" ]]; then
            candidate_epoch="$outcome_epoch"
        fi
        if [[ "$pid_epoch" -gt "$candidate_epoch" ]]; then
            candidate_epoch="$pid_epoch"
        fi

        if [[ "$candidate_epoch" -ge "$latest_epoch" ]]; then
            latest_epoch="$candidate_epoch"
            latest_provider="$provider"
        fi
    done

    [[ -n "$latest_provider" ]] || return 1
    printf '%s' "$latest_provider"
}

list_providers_for_beads() {
    local beads="$1"
    local -a providers=()
    shopt -s nullglob
    for dir in /tmp/dx-runner/*/; do
        [[ -d "$dir" ]] || continue
        local provider
        provider="$(basename "$dir")"
        if [[ -f "${dir}${beads}.meta" || -f "${dir}${beads}.outcome" || -f "${dir}${beads}.pid" ]]; then
            providers+=("$provider")
        fi
    done
    printf '%s\n' "${providers[@]}"
}

resolve_worktree() {
    local beads="$1"
    local from_flag="${2:-}"
    local resolved="$from_flag"
    if [[ -z "$resolved" && -n "$beads" ]]; then
        local provider
        provider="$(find_provider_for_beads "$beads")"
        job_paths "$beads" "$provider"
        resolved="$(meta_get "$META_FILE" "worktree" 2>/dev/null || true)"
    fi
    if [[ -z "$resolved" ]]; then
        resolved="$(pwd)"
    fi
    printf '%s' "$resolved"
}

# ============================================================================
# MUTATION DETECTION (V3.3 proven)
# ============================================================================

check_mutations() {
    local beads="$1"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"

    local worktree
    worktree="$(meta_get "$META_FILE" "worktree" 2>/dev/null || true)"

    if [[ -z "$worktree" || ! -d "$worktree" ]]; then
        echo 0
        return 0
    fi

    local changed=0
    if git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
        changed="$(cd "$worktree" && git status --porcelain --untracked-files=all 2>/dev/null | wc -l | tr -d ' ')" || changed=0
    fi
    if [[ "${changed:-0}" -eq 0 ]]; then
        changed="$(find "$worktree" -type f -newer "$META_FILE" 2>/dev/null | wc -l | tr -d ' ')" || changed=0
    fi

    echo "${changed:-0}"
}

write_mutation_marker() {
    local beads="$1"
    local count="$2"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"

    local first_checked_at=""
    if [[ -f "$MUTATION_FILE" ]]; then
        first_checked_at="$(meta_get "$MUTATION_FILE" "first_checked_at" 2>/dev/null || true)"
    fi
    if [[ -z "$first_checked_at" ]]; then
        first_checked_at="$(now_utc)"
    fi

    cat > "$MUTATION_FILE" <<EOF
beads=$beads
mutation_count=$count
first_checked_at=$first_checked_at
last_checked_at=$(now_utc)
EOF
}

# ============================================================================
# HEARTBEAT TRACKING (No-op Detection - bd-cbsb.17)
# ============================================================================

write_heartbeat() {
    local beads="$1"
    local provider="$2"
    local type="$3"  # tool_invocation, mutation, log_output
    local detail="${4:-}"
    
    job_paths "$beads" "$provider"
    
    local count=0
    if [[ -f "$HEARTBEAT_FILE" ]]; then
        count="$(meta_get "$HEARTBEAT_FILE" "count" 2>/dev/null || echo "0")"
    fi
    count=$((count + 1))
    
    cat > "$HEARTBEAT_FILE" <<EOF
beads=$beads
provider=$provider
count=$count
last_type=$type
last_detail=$detail
last_at=$(now_utc)
EOF
}

check_heartbeat_age() {
    local beads="$1"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"
    
    if [[ ! -f "$HEARTBEAT_FILE" ]]; then
        echo -1  # No heartbeat yet
        return 0
    fi
    
    local last_at now_epoch last_epoch
    last_at="$(meta_get "$HEARTBEAT_FILE" "last_at" 2>/dev/null || true)"
    
    if [[ -z "$last_at" ]]; then
        echo -1
        return 0
    fi
    
    now_epoch="$(date +%s)"
    last_epoch="$(parse_utc_epoch "${last_at}" 2>/dev/null || echo "$now_epoch")"
    
    echo $((now_epoch - last_epoch))
}

# ============================================================================
# PROCESS CONTROL
# ============================================================================

stop_job_internal() {
    local beads="$1"
    local provider="${2:-}"
    [[ -n "$provider" ]] || provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"
    
    local pid=""
    if [[ -f "$PID_FILE" ]]; then
        pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    fi
    
    if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]] && ps -p "$pid" >/dev/null 2>&1; then
        kill "$pid" 2>/dev/null || true
        sleep 1
        if ps -p "$pid" >/dev/null 2>&1; then
            kill -9 "$pid" 2>/dev/null || true
        fi
    fi
    
    if [[ -f "$MONITOR_PID_FILE" ]]; then
        local mpid
        mpid="$(cat "$MONITOR_PID_FILE" 2>/dev/null || true)"
        if [[ "$mpid" =~ ^[0-9]+$ ]] && ps -p "$mpid" >/dev/null 2>&1; then
            kill "$mpid" 2>/dev/null || true
        fi
    fi
    
    rm -f "$PID_FILE" "$MONITOR_PID_FILE"
}

process_state() {
    local pid="$1"
    if [[ -z "$pid" ]]; then
        printf "missing"
        return 0
    fi
    if ps -p "$pid" >/dev/null 2>&1; then
        printf "running"
        return 0
    fi
    printf "exited"
}

job_state() {
    local pid_file="$1"
    if [[ ! -f "$pid_file" ]]; then
        printf "missing"
        return 0
    fi
    local pid
    pid="$(cat "$pid_file" 2>/dev/null || true)"
    process_state "$pid"
}

parse_decimal_component() {
    local raw="$1"
    local normalized="${raw%.*}"
    if [[ -z "$normalized" ]]; then
        echo 0
        return 0
    fi
    if [[ "$normalized" =~ ^[0-9]+$ ]]; then
        echo $((10#$normalized))
        return 0
    fi
    echo 0
}

process_cpu_time() {
    local pid="$1"
    if [[ -z "$pid" ]]; then
        echo 0
        return 0
    fi
    local time_str
    time_str="$(ps -o time= -p "$pid" 2>/dev/null | tr -d ' ')" || { echo 0; return 0; }
    if [[ -z "$time_str" ]]; then
        echo 0
        return 0
    fi
    local parts seconds
    IFS=':' read -ra parts <<< "$time_str"
    case "${#parts[@]}" in
        2)
            seconds=$(( $(parse_decimal_component "${parts[0]}") * 60 + $(parse_decimal_component "${parts[1]}") ))
            ;;
        3)
            seconds=$(( $(parse_decimal_component "${parts[0]}") * 3600 + $(parse_decimal_component "${parts[1]}") * 60 + $(parse_decimal_component "${parts[2]}") ))
            ;;
        *)
            seconds=0
            ;;
    esac
    echo "$seconds"
}

classify_exit_reason() {
    local provider="$1"
    local exit_code="$2"
    local log_file="$3"
    local fallback_reason="${4:-process_exit_with_rc}"

    if [[ "$exit_code" -eq 0 ]]; then
        echo "process_exit_with_rc"
        return 0
    fi

    local tail_blob=""
    if [[ -f "$log_file" ]]; then
        tail_blob="$(tail -n 120 "$log_file" 2>/dev/null | tr '\n' ' ' || true)"
    fi
    local lowered
    lowered="$(printf '%s' "$tail_blob" | tr '[:upper:]' '[:lower:]')"

    if [[ "$provider" == "gemini" ]]; then
        if [[ "$lowered" == *"resource_exhausted"* || "$lowered" == *"model_capacity_exhausted"* || "$lowered" == *"429"* ]]; then
            echo "gemini_capacity_exhausted"
            return 0
        fi
    fi

    if [[ "$provider" == "opencode" ]]; then
        if [[ "$lowered" == *"429"* || "$lowered" == *"rate limit"* || "$lowered" == *"quota"* ]]; then
            echo "opencode_rate_limited"
            return 0
        fi
    fi

    echo "$fallback_reason"
}

next_action_for_reason() {
    local reason="$1"
    case "$reason" in
        gemini_capacity_exhausted)
            echo "retry_backoff_or_switch_to_opencode_or_cc_glm"
            ;;
        opencode_rate_limited)
            echo "retry_backoff_or_switch_to_gemini_or_cc_glm"
            ;;
        opencode_model_unavailable)
            echo "use_cc_glm_or_gemini"
            ;;
        awaiting_finalize_monitor_active)
            echo "wait_for_finalize_or_run_dx_runner_finalize"
            ;;
        stalled_no_progress)
            echo "run_dx_runner_finalize_or_restart"
            ;;
        provider_concurrency_cap_exceeded)
            echo "wait_for_provider_capacity_or_switch_provider"
            ;;
        no_commit_artifact)
            echo "verify_commit_stage_and_enable_commit_required_contract"
            ;;
        railway_auth_missing|railway_service_context_missing|railway_cli_missing)
            echo "enter_railway_shell_or_configure_auth_before_dispatch"
            ;;
        opencode_attach_mode_unavailable|opencode_attach_missing_url)
            echo "use_headless_run_or_provide_attach_url_with_supported_cli"
            ;;
        worktree_missing_for_opencode)
            echo "pass_valid_worktree_or_run_from_task_worktree"
            ;;
        # bd-8wdg.3: Manual stop actions
        manual_stop)
            echo "job_stopped_by_operator_review_logs"
            ;;
        killed)
            echo "job_killed_review_logs_and_restart_if_needed"
            ;;
        # bd-8wdg.9: No-op success (exit 0 but no mutations)
        exit_zero_no_mutations|no_op_success)
            echo "redispatch_with_guardrails_or_review_prompt_for_no_work"
            ;;
        # bd-8wdg.10: Slow start actions
        slow_start|startup_scan_in_progress|startup_cpu_progress_no_output|startup_grace_no_output)
            echo "wait_for_startup_completion_or_check_logs_for_progress"
            ;;
        # bd-8wdg.5: Scope guard violations
        path_outside_allowlist)
            echo "review_allowed_paths_and_worktree_changes"
            ;;
        mutation_budget_exceeded)
            echo "review_mutation_count_and_adjust_budget"
            ;;
        # bd-8wdg.6: Evidence gate
        unverified_claims)
            echo "provide_evidence_for_signoff_claims"
            ;;
        signoff_file_missing|outcome_missing)
            echo "ensure_signoff_file_and_outcome_exist"
            ;;
        *)
            echo "-"
            ;;
    esac
}

# ============================================================================
# GOVERNANCE GATES (Proven from cc-glm-job.sh V3.4)
# ============================================================================

baseline_gate_eval() {
    local worktree="$1"
    local required="$2"

    local runtime_commit=""
    local passed=false
    local reason_code="unknown"
    local details=""

    if [[ -z "$required" ]]; then
        reason_code="required_baseline_missing"
        details="required baseline is empty"
    elif [[ ! -d "$worktree" ]]; then
        reason_code="worktree_missing"
        details="worktree not found: $worktree"
    elif ! git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
        reason_code="not_a_git_repo"
        details="not a git worktree: $worktree"
    else
        runtime_commit="$(git -C "$worktree" rev-parse HEAD 2>/dev/null || true)"
        if [[ -z "$runtime_commit" ]]; then
            reason_code="runtime_commit_missing"
            details="failed to resolve runtime HEAD commit"
        elif ! git -C "$worktree" cat-file -e "${required}^{commit}" >/dev/null 2>&1; then
            reason_code="required_commit_missing"
            details="required commit not found in repo"
        elif git -C "$worktree" merge-base --is-ancestor "$required" "$runtime_commit" >/dev/null 2>&1; then
            passed=true
            reason_code="baseline_ok"
            details="runtime commit meets required baseline"
        else
            reason_code="baseline_not_met"
            details="runtime commit is behind required baseline"
        fi
    fi

    printf '%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$runtime_commit" "$required" "$details"
}

integrity_gate_eval() {
    local worktree="$1"
    local reported_commit="$2"
    local branch_name="${3:-}"

    local passed=false
    local reason_code="unknown"
    local details=""
    local branch_head=""

    if [[ -z "$reported_commit" ]]; then
        reason_code="reported_commit_missing"
        details="reported commit not provided"
    elif [[ ! -d "$worktree" ]]; then
        reason_code="worktree_missing"
        details="worktree not found: $worktree"
    elif ! git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
        reason_code="not_a_git_repo"
        details="not a git worktree: $worktree"
    else
        if [[ -z "$branch_name" ]]; then
            branch_name="$(git -C "$worktree" rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
        fi
        if [[ -z "$branch_name" ]]; then
            reason_code="branch_missing"
            details="could not resolve branch name"
        elif ! branch_head="$(git -C "$worktree" rev-parse "$branch_name" 2>/dev/null)"; then
            reason_code="branch_head_missing"
            details="branch not found: $branch_name"
            branch_head=""
        elif ! git -C "$worktree" cat-file -e "${reported_commit}^{commit}" >/dev/null 2>&1; then
            reason_code="reported_commit_not_found"
            details="reported commit does not exist"
        elif git -C "$worktree" merge-base --is-ancestor "$reported_commit" "$branch_head" >/dev/null 2>&1; then
            passed=true
            reason_code="integrity_ok"
            details="reported commit is ancestor of branch head"
        else
            reason_code="reported_not_ancestor"
            details="reported commit is not ancestor of branch head"
        fi
    fi

    printf '%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$branch_name" "$branch_head" "$reported_commit" "$details"
}

feature_key_gate_eval() {
    local worktree="$1"
    local feature_key="$2"
    local branch_name="${3:-}"
    local base_branch="${4:-master}"

    local passed=false
    local reason_code="unknown"
    local details=""
    local checked_commits=0
    local missing_commits=0

    if [[ -z "$feature_key" ]]; then
        reason_code="feature_key_missing"
        details="feature key is required"
    elif ! valid_feature_key "$feature_key"; then
        reason_code="feature_key_invalid_format"
        details="feature key must match ^bd-[a-z0-9]+(\\.[a-z0-9]+)*$"
    elif [[ ! -d "$worktree" ]]; then
        reason_code="worktree_missing"
        details="worktree not found: $worktree"
    elif ! git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
        reason_code="not_a_git_repo"
        details="not a git worktree: $worktree"
    else
        if [[ -z "$branch_name" ]]; then
            branch_name="$(git -C "$worktree" rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
        fi
        if [[ -z "$branch_name" ]]; then
            reason_code="branch_missing"
            details="could not resolve branch name"
        elif ! git -C "$worktree" rev-parse "$branch_name" >/dev/null 2>&1; then
            reason_code="branch_head_missing"
            details="branch not found: $branch_name"
        elif ! git -C "$worktree" rev-parse "$base_branch" >/dev/null 2>&1; then
            reason_code="base_branch_missing"
            details="base branch not found: $base_branch"
        else
            local commit
            while IFS= read -r commit; do
                [[ -n "$commit" ]] || continue
                checked_commits=$((checked_commits + 1))
                local body
                body="$(git -C "$worktree" show -s --format=%B "$commit" 2>/dev/null || true)"
                if ! printf '%s\n' "$body" | grep -q "^Feature-Key: ${feature_key}$"; then
                    missing_commits=$((missing_commits + 1))
                fi
            done < <(git -C "$worktree" rev-list "${base_branch}..${branch_name}" 2>/dev/null || true)

            if [[ "$checked_commits" -eq 0 ]]; then
                reason_code="no_commits_in_range"
                details="no commits in range ${base_branch}..${branch_name}"
            elif [[ "$missing_commits" -eq 0 ]]; then
                passed=true
                reason_code="feature_key_ok"
                details="all ${checked_commits} commits include Feature-Key: ${feature_key}"
            else
                reason_code="feature_key_missing_in_commits"
                details="${missing_commits}/${checked_commits} commits missing Feature-Key: ${feature_key}"
            fi
        fi
    fi

    printf '%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$branch_name" "$base_branch" "$feature_key" "$checked_commits" "$details"
}

# ============================================================================
# PERMISSION GATE (Worktree-only - bd-cbsb.16)
# ============================================================================

validate_worktree_path() {
    local path="$1"
    local allowed_prefixes=(
        "/tmp/agents"
        "/tmp/dx-runner"
        "/tmp/dxbench"
        "/tmp/dxbench_epyc6"
        "$HOME/agent-skills"
    )
    local extra_prefixes="${DX_RUNNER_EXTRA_ALLOWED_PREFIXES:-}"
    if [[ -n "$extra_prefixes" ]]; then
        local extra
        IFS=',' read -r -a extra <<< "$extra_prefixes"
        allowed_prefixes+=("${extra[@]}")
    fi
    
    # Check if path starts with any allowed prefix
    for prefix in "${allowed_prefixes[@]}"; do
        if [[ "$path" == "$prefix"* ]]; then
            return 0
        fi
    done
    
    return 1
}

check_permission_gate() {
    local beads="$1"
    local worktree="$2"
    
    if ! validate_worktree_path "$worktree"; then
        echo "DENIED:non_worktree_path:$worktree"
        return 1
    fi
    
    echo "OK:worktree_valid:$worktree"
    return 0
}

# ============================================================================
# UNIFIED PREFLIGHT (Provider-agnostic core)
# ============================================================================

unified_preflight() {
    local provider="${1:-}"
    local errors=0
    
    echo "=== Unified Preflight Check ==="
    echo "timestamp: $(now_utc)"
    echo "host: $(host_short)"
    echo "cwd: $(pwd)"
    [[ -n "$provider" ]] && echo "provider: $provider"
    
    # Check 1: Provider adapter exists
    if [[ -n "$provider" ]]; then
        echo -n "provider adapter: "
        local adapter="${ADAPTERS_DIR}/${provider}.sh"
        if [[ -f "$adapter" && -r "$adapter" ]]; then
            echo "OK ($adapter)"
        else
            echo "MISSING"
            echo "  ERROR: Adapter not found: $adapter"
            errors=$((errors + 1))
        fi
    fi
    
    # Provider-specific preflight
    if [[ -n "$provider" && -f "${ADAPTERS_DIR}/${provider}.sh" ]]; then
        source "${ADAPTERS_DIR}/${provider}.sh"
        if declare -f adapter_preflight >/dev/null 2>&1; then
            echo "--- Provider-specific: $provider ---"
            if ! adapter_preflight; then
                errors=$((errors + 1))
            fi
        fi
    fi

    # Railway auth capability gate (provider-aware)
    if [[ -n "$provider" ]]; then
        if ! railway_auth_gate "$provider"; then
            errors=$((errors + 1))
        fi
    fi
    
    echo ""
    if [[ $errors -eq 0 ]]; then
        echo "=== Preflight PASSED ==="
        return 0
    else
        echo "=== Preflight FAILED ($errors error(s)) ==="
        return 1
    fi
}

# ============================================================================
# HEALTH DETECTION (Deterministic substates + bd-8wdg hardening)
# ============================================================================

job_health_detail() {
    local beads="$1"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    
    if [[ -z "$provider" ]]; then
        for dir in /tmp/dx-runner/*/; do
            [[ -d "$dir" ]] || continue
            if [[ -f "${dir}${beads}.meta" ]]; then
                provider="$(basename "$dir")"
                break
            fi
        done
    fi
    
    job_paths "$beads" "$provider"
    
    local stall_threshold="${2:-$((STALL_MINUTES * 60))}"
    # bd-8wdg.10: Startup-aware thresholds
    local startup_grace="${STARTUP_FIRST_OUTPUT_GRACE_SEC:-300}"
    local mutation_grace="${STARTUP_FIRST_MUTATION_GRACE_SEC:-600}"

    local state="missing"
    local reason_code="pid_file_missing"
    local mutation_count=0
    local log_bytes=0
    local cpu_time=0
    local pid_age=0
    local log_age=0

    if [[ ! -f "$PID_FILE" ]]; then
        if [[ -f "$OUTCOME_FILE" ]]; then
            local oc_exit oc_reason
            oc_exit="$(meta_get "$OUTCOME_FILE" "exit_code")"
            oc_exit="${oc_exit:-1}"
            # bd-8wdg.3: Use outcome reason_code when available
            oc_reason="$(meta_get "$OUTCOME_FILE" "reason_code" 2>/dev/null || true)"
            local omut olog ocpu opid
            omut="$(meta_get "$OUTCOME_FILE" "mutations" 2>/dev/null || echo 0)"
            olog="$(meta_get "$OUTCOME_FILE" "log_bytes" 2>/dev/null || echo 0)"
            ocpu="$(meta_get "$OUTCOME_FILE" "cpu_time_sec" 2>/dev/null || echo 0)"
            opid="$(meta_get "$OUTCOME_FILE" "pid_age_sec" 2>/dev/null || echo 0)"
            [[ "$omut" =~ ^[0-9]+$ ]] || omut=0
            [[ "$olog" =~ ^[0-9]+$ ]] || olog=0
            [[ "$ocpu" =~ ^[0-9]+$ ]] || ocpu=0
            [[ "$opid" =~ ^[0-9]+$ ]] || opid=0
            
            # bd-8wdg.3 + bd-8wdg.9: Use explicit reason from outcome if available
            if [[ -n "$oc_reason" ]]; then
                if [[ "$oc_reason" == "manual_stop" || "$oc_reason" == "killed" ]]; then
                    printf "stopped|%s|%s|%s|%s|%s|0\n" "$oc_reason" "$omut" "$olog" "$ocpu" "$opid"
                elif [[ "$oc_exit" -eq 0 ]]; then
                    # bd-8wdg.9: Check for no-op success (exit 0 but no mutations)
                    if [[ "$omut" -eq 0 ]]; then
                        printf "no_op_success|exit_zero_no_mutations|%s|%s|%s|%s|0\n" "$omut" "$olog" "$ocpu" "$opid"
                    else
                        printf "exited_ok|%s|%s|%s|%s|%s|0\n" "$oc_reason" "$omut" "$olog" "$ocpu" "$opid"
                    fi
                else
                    printf "exited_err|%s|%s|%s|%s|%s|0\n" "$oc_reason" "$omut" "$olog" "$ocpu" "$opid"
                fi
            elif [[ "$oc_exit" -eq 0 ]]; then
                # bd-8wdg.9: Check for no-op success (exit 0 but no mutations)
                if [[ "$omut" -eq 0 ]]; then
                    printf "no_op_success|exit_zero_no_mutations|%s|%s|%s|%s|0\n" "$omut" "$olog" "$ocpu" "$opid"
                else
                    printf "exited_ok|outcome_exit_0|%s|%s|%s|%s|0\n" "$omut" "$olog" "$ocpu" "$opid"
                fi
            else
                printf "exited_err|outcome_exit_nonzero|%s|%s|%s|%s|0\n" "$omut" "$olog" "$ocpu" "$opid"
            fi
            return 0
        fi
        printf "%s|%s|%s|%s|%s|%s|%s\n" "$state" "$reason_code" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        return 0
    fi

    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ -z "$pid" || ! "$pid" =~ ^[0-9]+$ ]]; then
        rm -f "$PID_FILE"
        if [[ -f "$OUTCOME_FILE" ]]; then
            local oc_exit2 oc_reason2
            oc_exit2="$(meta_get "$OUTCOME_FILE" "exit_code")"
            oc_exit2="${oc_exit2:-1}"
            oc_reason2="$(meta_get "$OUTCOME_FILE" "reason_code" 2>/dev/null || true)"
            local omut2 olog2 ocpu2 opid2
            omut2="$(meta_get "$OUTCOME_FILE" "mutations" 2>/dev/null || echo 0)"
            olog2="$(meta_get "$OUTCOME_FILE" "log_bytes" 2>/dev/null || echo 0)"
            ocpu2="$(meta_get "$OUTCOME_FILE" "cpu_time_sec" 2>/dev/null || echo 0)"
            opid2="$(meta_get "$OUTCOME_FILE" "pid_age_sec" 2>/dev/null || echo 0)"
            [[ "$omut2" =~ ^[0-9]+$ ]] || omut2=0
            [[ "$olog2" =~ ^[0-9]+$ ]] || olog2=0
            [[ "$ocpu2" =~ ^[0-9]+$ ]] || ocpu2=0
            [[ "$opid2" =~ ^[0-9]+$ ]] || opid2=0
            
            # bd-8wdg.3 + bd-8wdg.9: Use explicit reason from outcome if available
            if [[ -n "$oc_reason2" ]]; then
                if [[ "$oc_reason2" == "manual_stop" || "$oc_reason2" == "killed" ]]; then
                    printf "stopped|%s|%s|%s|%s|%s|0\n" "$oc_reason2" "$omut2" "$olog2" "$ocpu2" "$opid2"
                elif [[ "$oc_exit2" -eq 0 ]]; then
                    # bd-8wdg.9: Check for no-op success (exit 0 but no mutations)
                    if [[ "$omut2" -eq 0 ]]; then
                        printf "no_op_success|exit_zero_no_mutations|%s|%s|%s|%s|0\n" "$omut2" "$olog2" "$ocpu2" "$opid2"
                    else
                        printf "exited_ok|%s|%s|%s|%s|%s|0\n" "$oc_reason2" "$omut2" "$olog2" "$ocpu2" "$opid2"
                    fi
                else
                    printf "exited_err|%s|%s|%s|%s|%s|0\n" "$oc_reason2" "$omut2" "$olog2" "$ocpu2" "$opid2"
                fi
            elif [[ "$oc_exit2" -eq 0 ]]; then
                # bd-8wdg.9: Check for no-op success (exit 0 but no mutations)
                if [[ "$omut2" -eq 0 ]]; then
                    printf "no_op_success|exit_zero_no_mutations|%s|%s|%s|%s|0\n" "$omut2" "$olog2" "$ocpu2" "$opid2"
                else
                    printf "exited_ok|outcome_exit_0|%s|%s|%s|%s|0\n" "$omut2" "$olog2" "$ocpu2" "$opid2"
                fi
            else
                printf "exited_err|outcome_exit_nonzero|%s|%s|%s|%s|0\n" "$omut2" "$olog2" "$ocpu2" "$opid2"
            fi
            return 0
        fi
        printf "missing|pid_empty|0|0|0|0|0\n"
        return 0
    fi

    if [[ -f "$PID_FILE" ]]; then
        local pid_mtime now
        pid_mtime="$(file_mtime_epoch "$PID_FILE" 2>/dev/null || echo "")"
        now="$(date +%s)"
        if [[ -n "$pid_mtime" ]]; then
            pid_age=$((now - pid_mtime))
        fi
    fi

    if [[ -f "$META_FILE" ]]; then
        mutation_count="$(check_mutations "$beads")"
        write_mutation_marker "$beads" "$mutation_count"
    fi

    if [[ -f "$LOG_FILE" ]]; then
        log_bytes="$(wc -c < "$LOG_FILE" | tr -d ' ')"
        local log_mtime now
        log_mtime="$(file_mtime_epoch "$LOG_FILE" 2>/dev/null || echo "")"
        now="$(date +%s)"
        if [[ -n "$log_mtime" ]]; then
            log_age=$((now - log_mtime))
        fi
    fi

    # Deterministic metric fallback from heartbeat when filesystem sampling lags.
    if [[ -f "$HEARTBEAT_FILE" ]]; then
        local hb_type hb_detail
        hb_type="$(meta_get "$HEARTBEAT_FILE" "last_type" 2>/dev/null || true)"
        hb_detail="$(meta_get "$HEARTBEAT_FILE" "last_detail" 2>/dev/null || true)"
        if [[ "$log_bytes" -eq 0 && "$hb_type" == "log_output" && "$hb_detail" =~ bytes=([0-9]+) ]]; then
            log_bytes="${BASH_REMATCH[1]}"
        fi
        if [[ "$mutation_count" -eq 0 && "$hb_type" == "mutation" && "$hb_detail" =~ count=([0-9]+) ]]; then
            mutation_count="${BASH_REMATCH[1]}"
        fi
    fi

    if ! ps -p "$pid" >/dev/null 2>&1; then
        if [[ -f "$MONITOR_PID_FILE" ]]; then
            local mpid
            mpid="$(cat "$MONITOR_PID_FILE" 2>/dev/null || true)"
            if [[ "$mpid" =~ ^[0-9]+$ ]] && ps -p "$mpid" >/dev/null 2>&1; then
                printf "awaiting_finalize|awaiting_finalize_monitor_active|%s|%s|0|%s|%s\n" "$mutation_count" "$log_bytes" "$pid_age" "$log_age"
                return 0
            fi
        fi
        finalize_exited_job "$beads" "$provider"
        if [[ -f "$OUTCOME_FILE" ]]; then
            local exit_code outcome_reason
            exit_code="$(meta_get "$OUTCOME_FILE" "exit_code")"
            exit_code="${exit_code:-1}"
            # bd-8wdg.3: Use outcome reason_code when available
            outcome_reason="$(meta_get "$OUTCOME_FILE" "reason_code" 2>/dev/null || true)"
            local omut3 olog3 ocpu3 opid3
            omut3="$(meta_get "$OUTCOME_FILE" "mutations" 2>/dev/null || echo "$mutation_count")"
            olog3="$(meta_get "$OUTCOME_FILE" "log_bytes" 2>/dev/null || echo "$log_bytes")"
            ocpu3="$(meta_get "$OUTCOME_FILE" "cpu_time_sec" 2>/dev/null || echo 0)"
            opid3="$(meta_get "$OUTCOME_FILE" "pid_age_sec" 2>/dev/null || echo "$pid_age")"
            [[ "$omut3" =~ ^[0-9]+$ ]] || omut3="${mutation_count:-0}"
            [[ "$olog3" =~ ^[0-9]+$ ]] || olog3="${log_bytes:-0}"
            [[ "$ocpu3" =~ ^[0-9]+$ ]] || ocpu3=0
            [[ "$opid3" =~ ^[0-9]+$ ]] || opid3="${pid_age:-0}"
            # bd-8wdg.3: Return explicit reason from outcome
            if [[ -n "$outcome_reason" ]]; then
                if [[ "$exit_code" -eq 0 && "$outcome_reason" != "manual_stop" && "$outcome_reason" != "killed" ]]; then
                    printf "exited_ok|%s|%s|%s|%s|%s|%s\n" "$outcome_reason" "$omut3" "$olog3" "$ocpu3" "$opid3" "$log_age"
                else
                    printf "stopped|%s|%s|%s|%s|%s|%s\n" "$outcome_reason" "$omut3" "$olog3" "$ocpu3" "$opid3" "$log_age"
                fi
            elif [[ "$exit_code" -eq 0 ]]; then
                printf "exited_ok|outcome_exit_0|%s|%s|%s|%s|%s\n" "$omut3" "$olog3" "$ocpu3" "$opid3" "$log_age"
            else
                printf "exited_err|outcome_exit_nonzero|%s|%s|%s|%s|%s\n" "$omut3" "$olog3" "$ocpu3" "$opid3" "$log_age"
            fi
            return 0
        fi
        if [[ "$pid_age" -gt "$stall_threshold" ]]; then
            printf "stalled|stalled_no_progress|%s|%s|0|%s|%s\n" "$mutation_count" "$log_bytes" "$pid_age" "$log_age"
            return 0
        fi
        if [[ "$log_bytes" -eq 0 ]]; then
            printf "stalled|process_exited_no_output|%s|%s|0|%s|%s\n" "$mutation_count" "$log_bytes" "$pid_age" "$log_age"
            return 0
        fi
        printf "exited_err|process_exited_without_outcome|%s|%s|0|%s|%s\n" "$mutation_count" "$log_bytes" "$pid_age" "$log_age"
        return 0
    fi

    if [[ -f "$META_FILE" ]]; then
        local blocked
        blocked="$(meta_get "$META_FILE" "blocked")"
        if [[ "$blocked" == "true" ]]; then
            printf "blocked|blocked_flag_set|%s|%s|0|%s|%s\n" "$mutation_count" "$log_bytes" "$pid_age" "$log_age"
            return 0
        fi
    fi

    cpu_time="$(process_cpu_time "$pid")"

    # bd-8wdg.10: Startup-aware health detection
    # Check if we're in the startup grace period
    local in_startup_grace=false
    local in_mutation_grace=false
    if [[ "$pid_age" -lt "$startup_grace" ]]; then
        in_startup_grace=true
    fi
    if [[ "$pid_age" -lt "$mutation_grace" ]]; then
        in_mutation_grace=true
    fi

    # Check for no-op (bd-cbsb.17) - with startup awareness (bd-8wdg.10)
    local heartbeat_age
    heartbeat_age="$(check_heartbeat_age "$beads")"
    local noop_threshold=300  # 5 minutes without heartbeat
    
    # bd-8wdg.10: Don't classify as no_op during startup grace if there's CPU activity
    if [[ "$heartbeat_age" -gt "$noop_threshold" && "$mutation_count" -eq 0 && "$log_bytes" -eq 0 ]]; then
        if [[ "$in_startup_grace" == true && "$cpu_time" -gt 0 ]]; then
            # Slow-start: provider is doing read-only scans, CPU active but no output yet
            printf "slow_start|startup_scan_in_progress|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            return 0
        fi
        printf "no_op|no_heartbeat_no_mutation|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        return 0
    fi

    if [[ "$log_bytes" -eq 0 ]]; then
        if [[ "$mutation_count" -gt 0 ]]; then
            printf "silent_mutation|worktree_changed_no_output|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            return 0
        fi
        if [[ "$cpu_time" -gt 0 ]]; then
            # bd-8wdg.10: Distinguish slow-start from stalled
            if [[ "$in_startup_grace" == true ]]; then
                printf "slow_start|startup_cpu_progress_no_output|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            elif [[ "$pid_age" -gt "$stall_threshold" ]]; then
                printf "waiting_first_output|cpu_progress_no_output_past_threshold|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            else
                printf "launching|cpu_progress_no_output|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            fi
            return 0
        fi
        # bd-8wdg.10: Give more grace during startup for no-output
        if [[ "$in_startup_grace" == true ]]; then
            printf "launching|startup_grace_no_output|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        elif [[ "$pid_age" -gt "$stall_threshold" ]]; then
            printf "stalled|no_output_no_progress_after_threshold|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        else
            printf "launching|no_output_within_grace|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        fi
        return 0
    fi

    if [[ -f "$META_FILE" ]]; then
        local prev_cpu
        prev_cpu="$(meta_get "$META_FILE" "last_cpu_time")"
        prev_cpu="${prev_cpu:-0}"
        meta_set "$META_FILE" "last_cpu_time" "$cpu_time"
        if [[ "$cpu_time" -gt "$prev_cpu" ]]; then
            printf "healthy|cpu_progress|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
            return 0
        fi
    fi

    if [[ "$log_age" -gt "$stall_threshold" ]]; then
        printf "stalled|stale_log_and_no_cpu_progress|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
        return 0
    fi

    printf "healthy|recent_log_activity|%s|%s|%s|%s|%s\n" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
}

# ============================================================================
# LOG/OUTCOME ROTATION
# ============================================================================

rotate_log() {
    local log_file="$1"
    if [[ ! -f "$log_file" ]]; then
        return 0
    fi

    local log_bytes
    log_bytes="$(wc -c < "$log_file" | tr -d ' ')"
    if [[ "$log_bytes" -eq 0 ]]; then
        rm -f "$log_file"
        return 0
    fi

    local base_dir base_name n=1
    base_dir="$(dirname "$log_file")"
    base_name="$(basename "$log_file" .log)"
    while [[ -f "${base_dir}/${base_name}.log.${n}" ]]; do
        n=$((n + 1))
    done

    mv "$log_file" "${base_dir}/${base_name}.log.${n}"
}

rotate_outcome() {
    local outcome_file="$1"
    if [[ ! -f "$outcome_file" ]]; then
        return 0
    fi

    local base_dir base_name n=1
    base_dir="$(dirname "$outcome_file")"
    base_name="$(basename "$outcome_file" .outcome)"

    while [[ -f "${base_dir}/${base_name}.outcome.${n}" ]]; do
        n=$((n + 1))
    done

    mv "$outcome_file" "${base_dir}/${base_name}.outcome.${n}"
}

wait_for_rc_file() {
    local rc_file="$1"
    local grace_sec="${2:-${DX_RUNNER_RC_GRACE_SEC:-5}}"
    local deadline now
    deadline=$(( $(date +%s) + grace_sec ))
    while true; do
        if [[ -f "$rc_file" ]]; then
            return 0
        fi
        now="$(date +%s)"
        if [[ "$now" -ge "$deadline" ]]; then
            return 1
        fi
        sleep 0.2
    done
}

check_commit_artifact() {
    local meta_file="$1"
    local worktree start_head current_head reported_commit

    worktree="$(meta_get "$meta_file" "worktree" 2>/dev/null || true)"
    start_head="$(meta_get "$meta_file" "start_head_commit" 2>/dev/null || true)"
    [[ -n "$worktree" && -d "$worktree" ]] || { echo "worktree_missing"; return 1; }
    git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1 || { echo "not_git_worktree"; return 1; }

    current_head="$(git -C "$worktree" rev-parse HEAD 2>/dev/null || true)"
    [[ -n "$current_head" ]] || { echo "head_unresolvable"; return 1; }

    if [[ -n "$start_head" && "$start_head" != "none" && "$current_head" == "$start_head" ]]; then
        echo "head_unchanged"
        return 1
    fi

    reported_commit="$current_head"
    if [[ -n "$start_head" && "$start_head" != "none" ]]; then
        if ! git -C "$worktree" merge-base --is-ancestor "$start_head" "$current_head" >/dev/null 2>&1; then
            echo "head_not_descendant"
            return 1
        fi
    fi
    echo "$reported_commit"
    return 0
}

persist_outcome() {
    local beads="$1"
    local exit_code="$2"
    local outcome_file="$3"
    local meta_file="$4"
    local reason_code="${5:-process_exit}"

    local state="failed"
    if [[ "$exit_code" -eq 0 ]]; then
        state="success"
    elif [[ "$exit_code" -eq 137 ]]; then
        state="killed"
    elif [[ "$exit_code" -eq 23 ]]; then
        state="no_op"
    fi

    local require_commit_artifact commit_check_result reported_commit
    require_commit_artifact="$(meta_get "$meta_file" "require_commit_artifact" 2>/dev/null || echo "0")"
    if [[ "$state" == "success" ]] && is_truthy "$require_commit_artifact"; then
        commit_check_result="$(check_commit_artifact "$meta_file" 2>/dev/null || true)"
        if [[ "$commit_check_result" =~ ^[a-f0-9]{40}$ ]]; then
            reported_commit="$commit_check_result"
            meta_set "$meta_file" "reported_commit" "$reported_commit"
        else
            state="failed"
            exit_code=44
            reason_code="no_commit_artifact"
            reported_commit="-"
        fi
    fi

    local duration_sec="-"
    local started_at=""
    if [[ -f "$meta_file" ]]; then
        started_at="$(meta_get "$meta_file" "started_at")"
        if [[ -n "$started_at" ]]; then
            local now_epoch start_epoch
            now_epoch="$(date +%s)"
            start_epoch="$(parse_utc_epoch "${started_at}" 2>/dev/null || echo "")"
            if [[ -n "$start_epoch" ]]; then
                duration_sec=$((now_epoch - start_epoch))
                if [[ "$duration_sec" -lt 0 ]]; then
                    duration_sec=0
                fi
            fi
        fi
    fi

    local final_retries="0"
    if [[ -f "$meta_file" ]]; then
        final_retries="$(meta_get "$meta_file" "retries")"
        final_retries="${final_retries:-0}"
    fi

    local run_id
    run_id="$(date +%Y%m%d%H%M%S)"
    local selected_model fallback_reason provider run_instance host cwd worktree
    selected_model="$(meta_get "$meta_file" "selected_model" 2>/dev/null || true)"
    fallback_reason="$(meta_get "$meta_file" "fallback_reason" 2>/dev/null || true)"
    provider="$(meta_get "$meta_file" "provider" 2>/dev/null || true)"
    run_instance="$(meta_get "$meta_file" "run_instance" 2>/dev/null || true)"
    host="$(meta_get "$meta_file" "host" 2>/dev/null || true)"
    cwd="$(meta_get "$meta_file" "cwd" 2>/dev/null || true)"
    worktree="$(meta_get "$meta_file" "worktree" 2>/dev/null || true)"
    selected_model="${selected_model:-unknown}"
    fallback_reason="${fallback_reason:-none}"
    provider="${provider:-unknown}"
    run_instance="${run_instance:-unknown}"
    host="${host:-$(host_short)}"
    cwd="${cwd:-$(pwd)}"
    worktree="${worktree:--}"
    if [[ -z "${reported_commit:-}" ]]; then
        reported_commit="$(meta_get "$meta_file" "reported_commit" 2>/dev/null || true)"
    fi
    reported_commit="${reported_commit:--}"

    local snap_mutations=0 snap_log_bytes=0 snap_cpu=0 snap_pid_age=0
    if [[ "$provider" != "unknown" ]]; then
        job_paths "$beads" "$provider"
        if [[ -f "$LOG_FILE" ]]; then
            snap_log_bytes="$(wc -c < "$LOG_FILE" | tr -d ' ')" || snap_log_bytes=0
        fi
        if [[ -f "$META_FILE" ]]; then
            snap_mutations="$(check_mutations "$beads" 2>/dev/null || echo 0)"
            snap_cpu="$(meta_get "$META_FILE" "last_cpu_time" 2>/dev/null || echo 0)"
        fi
        if [[ -f "$PID_FILE" ]]; then
            local now pid_mtime
            now="$(date +%s)"
            pid_mtime="$(file_mtime_epoch "$PID_FILE" 2>/dev/null || echo "$now")"
            snap_pid_age=$((now - pid_mtime))
        fi
    fi

    cat > "$outcome_file" <<EOF
beads=$beads
provider=$provider
run_id=$run_id
exit_code=$exit_code
state=$state
reason_code=$reason_code
completed_at=$(now_utc)
duration_sec=$duration_sec
retries=$final_retries
selected_model=$selected_model
fallback_reason=$fallback_reason
run_instance=$run_instance
host=$host
cwd=$cwd
worktree=$worktree
mutations=${snap_mutations:-0}
log_bytes=${snap_log_bytes:-0}
cpu_time_sec=${snap_cpu:-0}
pid_age_sec=${snap_pid_age:-0}
reported_commit=${reported_commit}
EOF
}

start_completion_monitor() {
    local beads="$1"
    local provider="$2"
    local pid="$3"
    local meta_file="$4"
    local outcome_file="$5"
    local rc_file="$6"
    local pid_file="$7"
    local log_file="$8"

    (
        local prev_log_bytes=0
        local prev_cpu=0
        local last_mutation_check=0
        while ps -p "$pid" >/dev/null 2>&1; do
            if [[ -f "$log_file" ]]; then
                local log_bytes
                log_bytes="$(wc -c < "$log_file" | tr -d ' ')" || log_bytes=0
                if [[ "$log_bytes" -gt "$prev_log_bytes" ]]; then
                    write_heartbeat "$beads" "$provider" "log_output" "bytes=$log_bytes"
                    prev_log_bytes="$log_bytes"
                fi
            fi
            local cpu_now
            cpu_now="$(process_cpu_time "$pid")"
            if [[ "$cpu_now" -gt "$prev_cpu" ]]; then
                write_heartbeat "$beads" "$provider" "cpu_progress" "cpu=$cpu_now"
                prev_cpu="$cpu_now"
            fi
            local now_epoch
            now_epoch="$(date +%s)"
            if [[ -f "$meta_file" && $((now_epoch - last_mutation_check)) -ge 10 ]]; then
                local mutations
                mutations="$(check_mutations "$beads")"
                if [[ "${mutations:-0}" -gt 0 ]]; then
                    write_heartbeat "$beads" "$provider" "mutation" "count=$mutations"
                fi
                last_mutation_check="$now_epoch"
            fi
            sleep 2
        done

        local exit_code=1
        local reason_code="monitor_no_rc_file"
        if wait_for_rc_file "$rc_file"; then
            exit_code="$(cat "$rc_file" 2>/dev/null || echo "1")"
            reason_code="$(classify_exit_reason "$provider" "$exit_code" "$log_file" "process_exit_with_rc")"
        else
            reason_code="$(classify_exit_reason "$provider" "$exit_code" "$log_file" "monitor_no_rc_file")"
        fi
        if [[ ! -f "$outcome_file" ]]; then
            persist_outcome "$beads" "$exit_code" "$outcome_file" "$meta_file" "$reason_code"
        fi
        write_heartbeat "$beads" "$provider" "completed" "exit_code=$exit_code"
        rm -f "$pid_file" "$MONITOR_PID_FILE"
    ) &
    local monitor_pid="$!"
    disown "$monitor_pid" 2>/dev/null || true
    echo "$monitor_pid" > "$MONITOR_PID_FILE"
    meta_set "$meta_file" "monitor_pid" "$monitor_pid"
}

finalize_exited_job() {
    local beads="$1"
    local provider="$2"
    job_paths "$beads" "$provider"
    [[ -f "$PID_FILE" ]] || return 0
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    [[ "$pid" =~ ^[0-9]+$ ]] || {
        rm -f "$PID_FILE"
        return 0
    }
    if ps -p "$pid" >/dev/null 2>&1; then
        return 0
    fi
    if [[ ! -f "$OUTCOME_FILE" ]]; then
        local rc=1
        local reason="late_finalize_no_rc"
        if wait_for_rc_file "$RC_FILE"; then
            rc="$(cat "$RC_FILE" 2>/dev/null || echo "1")"
            reason="$(classify_exit_reason "$provider" "$rc" "$LOG_FILE" "late_finalize_from_rc_file")"
        else
            reason="$(classify_exit_reason "$provider" "$rc" "$LOG_FILE" "late_finalize_no_rc")"
        fi
        persist_outcome "$beads" "$rc" "$OUTCOME_FILE" "$META_FILE" "$reason"
    fi
    rm -f "$PID_FILE" "$MONITOR_PID_FILE"
}

force_finalize_job() {
    local beads="$1"
    local provider="$2"
    local reason_code="${3:-forced_finalization}"
    local exit_code="${4:-1}"
    
    job_paths "$beads" "$provider"
    
    local pid=""
    if [[ -f "$PID_FILE" ]]; then
        pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    fi
    
    if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]] && ps -p "$pid" >/dev/null 2>&1; then
        kill -TERM "$pid" 2>/dev/null || true
        sleep 2
        if ps -p "$pid" >/dev/null 2>&1; then
            kill -KILL "$pid" 2>/dev/null || true
        fi
    fi
    
    if [[ ! -f "$OUTCOME_FILE" ]]; then
        persist_outcome "$beads" "$exit_code" "$OUTCOME_FILE" "$META_FILE" "$reason_code"
    fi
    
    echo "${exit_code}" > "$RC_FILE" 2>/dev/null || true
    
    rm -f "$PID_FILE" "$MONITOR_PID_FILE"
    
    echo "force_finalized beads=$beads reason=$reason_code exit_code=$exit_code"
}

check_timeout_conditions() {
    local beads="$1"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"
    
    if [[ ! -f "$META_FILE" || ! -f "$PID_FILE" ]]; then
        return 1
    fi
    
    local pid started_at now_epoch start_epoch runtime_sec
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    
    if [[ ! "$pid" =~ ^[0-9]+$ ]] || ! ps -p "$pid" >/dev/null 2>&1; then
        return 1
    fi
    
    started_at="$(meta_get "$META_FILE" "started_at" 2>/dev/null || true)"
    now_epoch="$(date +%s)"
    
    if [[ -n "$started_at" ]]; then
        start_epoch="$(parse_utc_epoch "${started_at}" 2>/dev/null || echo "$now_epoch")"
        runtime_sec=$((now_epoch - start_epoch))
    else
        local pid_mtime
        pid_mtime="$(file_mtime_epoch "$PID_FILE" 2>/dev/null || echo "$now_epoch")"
        runtime_sec=$((now_epoch - pid_mtime))
    fi
    
    local max_runtime_sec=$((MAX_RUNTIME_MINUTES * 60))
    if [[ "$runtime_sec" -gt "$max_runtime_sec" ]]; then
        echo "max_runtime_exceeded|${runtime_sec}|${max_runtime_sec}"
        return 0
    fi
    
    local mutation_count
    mutation_count="$(check_mutations "$beads")"
    write_mutation_marker "$beads" "$mutation_count"
    
    local first_mutation_check first_check_epoch no_mut_sec
    first_mutation_check="$(meta_get "$MUTATION_FILE" "first_checked_at" 2>/dev/null || true)"
    
    if [[ "$mutation_count" -eq 0 && -n "$first_mutation_check" ]]; then
        first_check_epoch="$(parse_utc_epoch "${first_mutation_check}" 2>/dev/null || echo "$now_epoch")"
        no_mut_sec=$((now_epoch - first_check_epoch))
        local no_mut_timeout_sec=$((NO_MUTATION_TIMEOUT_MINUTES * 60))
        if [[ "$no_mut_sec" -gt "$no_mut_timeout_sec" ]]; then
            echo "no_mutation_timeout|${no_mut_sec}|${no_mut_timeout_sec}"
            return 0
        fi
    fi
    
    local heartbeat_age
    heartbeat_age="$(check_heartbeat_age "$beads")"
    local extended_stall_sec=$((STALL_MINUTES * 60 * 2))
    if [[ "$heartbeat_age" -gt "$extended_stall_sec" && "$mutation_count" -eq 0 ]]; then
        echo "extended_stall|${heartbeat_age}|${extended_stall_sec}"
        return 0
    fi
    
    return 1
}

prune_job() {
    local beads="$1"
    local provider="$2"
    job_paths "$beads" "$provider"
    local pruned=0

    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid="$(cat "$PID_FILE" 2>/dev/null || true)"
        if [[ ! "$pid" =~ ^[0-9]+$ ]]; then
            rm -f "$PID_FILE"
            pruned=1
        elif ! ps -p "$pid" >/dev/null 2>&1; then
            # If monitor is still alive, keep PID/meta for awaiting_finalize state.
            if [[ -f "$MONITOR_PID_FILE" ]]; then
                local mpid
                mpid="$(cat "$MONITOR_PID_FILE" 2>/dev/null || true)"
                if [[ "$mpid" =~ ^[0-9]+$ ]] && ps -p "$mpid" >/dev/null 2>&1; then
                    echo "$pruned"
                    return 0
                fi
            fi
            finalize_exited_job "$beads" "$provider"
            pruned=1
        fi
    fi
    echo "$pruned"
}

persist_contract() {
    local beads="$1"
    local provider="$2"
    local contract_file="$3"
    
    job_paths "$beads" "$provider"
    
    local auth_source model base_url
    auth_source="$(meta_get "$META_FILE" "auth_source" 2>/dev/null || echo "unknown")"
    model="$(meta_get "$META_FILE" "model" 2>/dev/null || echo "${PROVIDER_DEFAULT_MODEL[$provider]:-unknown}")"
    base_url="$(meta_get "$META_FILE" "base_url" 2>/dev/null || echo "default")"

    cat > "$contract_file" <<EOF
# Runtime contract for $beads (generated $(now_utc))
provider=$provider
auth_source=${auth_source}
model=${model}
base_url=${base_url}
EOF
}

# ============================================================================
# MODEL RESOLUTION (OpenCode capability - bd-cbsb.15)
# ============================================================================

resolve_model() {
    local provider="$1"
    local preferred="$2"
    local host="${3:-$(hostname 2>/dev/null | cut -d. -f1)}"
    
    # Get available models from provider
    local available_models=()
    if [[ -f "${ADAPTERS_DIR}/${provider}.sh" ]]; then
        source "${ADAPTERS_DIR}/${provider}.sh"
        if declare -f adapter_list_models >/dev/null 2>&1; then
            mapfile -t available_models < <(adapter_list_models)
        fi
    fi
    
    # Check if preferred is available
    if [[ -n "$preferred" ]]; then
        for m in "${available_models[@]}"; do
            if [[ "$m" == "$preferred" ]]; then
                echo "$preferred|preferred|"
                return 0
            fi
        done
    fi
    
    # Use fallback chain
    local fallback_chain="${PROVIDER_FALLBACK_CHAIN[$provider]:-}"
    if [[ -n "$fallback_chain" ]]; then
        IFS=':' read -ra fallbacks <<< "$fallback_chain"
        for fb in "${fallbacks[@]}"; do
            for m in "${available_models[@]}"; do
                if [[ "$m" == "$fb" ]]; then
                    echo "$fb|fallback|preferred $preferred not available"
                    return 0
                fi
            done
        done
    fi
    
    # Use provider default
    local default="${PROVIDER_DEFAULT_MODEL[$provider]:-}"
    if [[ -n "$default" ]]; then
        echo "$default|default|no preferred model available"
        return 0
    fi
    
    echo "|unavailable|no models found for provider $provider"
    return 1
}

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

STALL_MINUTES=20
WATCHDOG_INTERVAL=60
WATCHDOG_MAX_RETRIES=1
OUTPUT_JSON=false
NO_ANSI=false
USE_PTY=false
PRESERVE_CONTRACT=false
PROVIDER=""
BEADS=""
PROMPT_FILE=""
WORKTREE=""
REPO=""
REQUIRED_BASELINE=""
REPORTED_COMMIT=""
BRANCH_NAME=""
FEATURE_KEY=""
BASE_BRANCH="master"
TAIL_LINES=20
SHOW_MUTATIONS=false
REPORT_FORMAT="json"
MODEL_ID=""
RECENT_COUNT=0
COMPACT_LOGS=false
REASON_CODE=""
EXIT_CODE=""
PROBE_ID=""
WRITE_PROBE=false
REQUIRE_COMMIT_ARTIFACT="${DX_RUNNER_REQUIRE_COMMIT_ARTIFACT:-0}"
REQUIRE_RAILWAY_AUTH="${DX_RUNNER_REQUIRE_RAILWAY_AUTH:-0}"

# bd-8wdg: Profile and scope options
PROFILE=""
ALLOW_MODEL_OVERRIDE="${DX_RUNNER_ALLOW_MODEL_OVERRIDE:-0}"
ALLOWED_PATHS_FILE=""
MUTATION_BUDGET=""
FILE_BUDGET=""
EVIDENCE_SIGNOFF_FILE=""

MAX_RUNTIME_MINUTES="${DX_RUNNER_MAX_RUNTIME_MINUTES:-120}"
NO_MUTATION_TIMEOUT_MINUTES="${DX_RUNNER_NO_MUTATION_TIMEOUT_MINUTES:-30}"

parse_common_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --beads)
                BEADS="${2:-}"
                shift 2
                ;;
            --provider)
                PROVIDER="${2:-}"
                shift 2
                ;;
            --profile)
                PROFILE="${2:-}"
                shift 2
                ;;
            --prompt-file)
                PROMPT_FILE="${2:-}"
                shift 2
                ;;
            --repo)
                REPO="${2:-}"
                shift 2
                ;;
            --worktree)
                WORKTREE="${2:-}"
                shift 2
                ;;
            --stall-minutes)
                STALL_MINUTES="${2:-20}"
                shift 2
                ;;
            --interval)
                WATCHDOG_INTERVAL="${2:-60}"
                shift 2
                ;;
            --max-retries)
                WATCHDOG_MAX_RETRIES="${2:-1}"
                shift 2
                ;;
            --pty)
                USE_PTY=true
                shift
                ;;
            --no-ansi)
                NO_ANSI=true
                shift
                ;;
            --preserve-contract)
                PRESERVE_CONTRACT=true
                shift
                ;;
            --json)
                OUTPUT_JSON=true
                shift
                ;;
            --mutations)
                SHOW_MUTATIONS=true
                shift
                ;;
            --required-baseline)
                REQUIRED_BASELINE="${2:-}"
                shift 2
                ;;
            --reported-commit)
                REPORTED_COMMIT="${2:-}"
                shift 2
                ;;
            --branch)
                BRANCH_NAME="${2:-}"
                shift 2
                ;;
            --feature-key)
                FEATURE_KEY="${2:-}"
                shift 2
                ;;
            --base-branch)
                BASE_BRANCH="${2:-}"
                shift 2
                ;;
            --lines)
                TAIL_LINES="${2:-20}"
                shift 2
                ;;
            --format)
                REPORT_FORMAT="${2:-json}"
                shift 2
                ;;
            --model)
                MODEL_ID="${2:-}"
                shift 2
                ;;
            --recent)
                RECENT_COUNT="${2:-5}"
                shift 2
                ;;
            --compact)
                COMPACT_LOGS=true
                shift
                ;;
            --max-runtime)
                MAX_RUNTIME_MINUTES="${2:-120}"
                shift 2
                ;;
            --no-mutation-timeout)
                NO_MUTATION_TIMEOUT_MINUTES="${2:-30}"
                shift 2
                ;;
            --reason)
                REASON_CODE="${2:-forced_finalization}"
                shift 2
                ;;
            --exit-code)
                EXIT_CODE="${2:-1}"
                shift 2
                ;;
            --probe-id)
                PROBE_ID="${2:-}"
                shift 2
                ;;
            --write-probe)
                WRITE_PROBE=true
                shift
                ;;
            --require-commit-artifact)
                REQUIRE_COMMIT_ARTIFACT=1
                shift
                ;;
            --require-railway-auth)
                REQUIRE_RAILWAY_AUTH=1
                shift
                ;;
            --allow-model-override)
                ALLOW_MODEL_OVERRIDE=1
                export DX_RUNNER_ALLOW_MODEL_OVERRIDE=1
                shift
                ;;
            --allowed-paths-file)
                ALLOWED_PATHS_FILE="${2:-}"
                shift 2
                ;;
            --mutation-budget)
                MUTATION_BUDGET="${2:-}"
                shift 2
                ;;
            --file-budget)
                FILE_BUDGET="${2:-}"
                shift 2
                ;;
            --signoff-file)
                EVIDENCE_SIGNOFF_FILE="${2:-}"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown arg: $1" >&2
                usage
                exit 2
                ;;
        esac
    done
}

usage() {
    cat <<'EOF'
dx-runner (V2.0 - Unified Multi-Provider Dispatch Runner with Hardening)

Usage:
  dx-runner start --beads <id> --provider <name> --prompt-file <path> [options]
  dx-runner start --beads <id> --profile <name> --prompt-file <path> [options]
  dx-runner status [--beads <id>] [--recent <n>] [--json]
  dx-runner check --beads <id> [--stall-minutes <n>] [--json]
  dx-runner health [--beads <id>] [--json]
  dx-runner logs --beads <id> [--lines <n>] [--compact]
  dx-runner restart --beads <id>
  dx-runner stop --beads <id>
  dx-runner prune [--beads <id>] [--json]
  dx-runner watchdog [--interval <sec>] [--max-retries <n>]
  dx-runner report --beads <id> [--format json|markdown]
  dx-runner preflight [--provider <name>] [--profile <name>]
  dx-runner probe --provider <name> --model <id>
  dx-runner profiles [--list] [--show <name>]
  dx-runner beads-gate [--repo <path>] [--probe-id <id>] [--write-probe]
  dx-runner baseline-gate [--beads <id> | --worktree <path>] --required-baseline <sha>
  dx-runner integrity-gate [--beads <id> | --worktree <path>] --reported-commit <sha>
  dx-runner feature-key-gate [--beads <id> | --worktree <path>] --feature-key <bd-id>
  dx-runner evidence-gate --beads <id> --signoff-file <path>
  dx-runner scope-gate --beads <id> [--allowed-paths-file <path>] [--mutation-budget <n>]
  dx-runner finalize --beads <id> [--reason <code>] [--exit-code <n>]

Providers:
  cc-glm    Claude via Z.ai (reliability backstop)
  opencode  OpenCode headless (primary throughput, strict canonical GLM-5)
  gemini    Gemini CLI (parallel capacity)

Built-in Profiles (bd-8wdg.1):
  opencode-prod    Production-safe OpenCode with strict governance
  cc-glm-fallback  Reliability backstop profile
  gemini-burst     Burst capacity using Gemini CLI
  dev              Permissive development profile

Commands:
  start        Launch a job with specified provider or profile
  status       Show status table of jobs
  check        Check single job health (exit 2 if stalled, 3 if error)
  health       Show detailed health state
  restart      Restart a job (preserves metadata)
  stop         Stop a running job
  prune        Cleanup stale/ghost job records
  watchdog     Run watchdog loop
  report       Generate job report
  preflight    Verify prerequisites
  probe        Test provider/model availability
  profiles     List or show configuration profiles
  beads-gate   Verify Beads DB connectivity and repo binding
  baseline-gate Verify runtime commit meets baseline
  integrity-gate Verify reported commit exists
  feature-key-gate Verify Feature-Key trailers
  evidence-gate Verify QA/signoff evidence claims (bd-8wdg.6)
  scope-gate   Verify scope and mutation budget (bd-8wdg.5)
  finalize     Force finalize a stuck job

Exit Codes:
  0  Success
  1  General error
  2  Job stalled
  3  Job exited with error
  10 Auth resolution failed
  11 Token file error
  20 Provider not found
  21 Preflight failed
  22 Permission denied (non-worktree path)
  23 No-op detected
  24 Beads gate failed
  25 Model unavailable
  26 Provider concurrency cap exceeded
  27 Provider execution mode unsupported/misconfigured
  28 Model override blocked (drift protection)
  29 Scope guard violation
  30 Evidence gate failed

Notable start/preflight options:
  --profile <name>            Use profile for provider/model/strictness (bd-8wdg.1)
  --allow-model-override      Allow OPENCODE_MODEL env to override (bd-8wdg.2)
  --require-commit-artifact   Enforce commit artifact on successful exit
  --require-railway-auth      Enforce Railway auth + service context preflight
  --allowed-paths-file <path> Enforce path allowlist (bd-8wdg.5)
  --mutation-budget <n>       Max allowed mutations (bd-8wdg.5)

Health States:
  launching, waiting_first_output, slow_start (bd-8wdg.10), silent_mutation, stalled,
  healthy, awaiting_finalize, exited_ok, exited_err, stopped, blocked, missing, no_op

Health Reason Codes:
  slow_start*              Provider doing startup scans (bd-8wdg.10)
  manual_stop              Job stopped by operator (bd-8wdg.3)
  outcome_exit_0           Normal completion with success
  outcome_exit_nonzero     Normal completion with error
EOF
}

# ============================================================================
# COMMAND IMPLEMENTATIONS
# ============================================================================

start_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "start requires --beads" >&2; exit 2; }
    [[ -n "$PROMPT_FILE" ]] || { echo "start requires --prompt-file" >&2; exit 2; }
    [[ -f "$PROMPT_FILE" ]] || { echo "prompt file not found: $PROMPT_FILE" >&2; exit 1; }
    
    # bd-8wdg.1: Profile support - load profile if specified
    if [[ -n "$PROFILE" ]]; then
        local profile_load_result
        profile_load_result="$(load_profile "$PROFILE" 2>&1)" || {
            echo "profile load failed: $profile_load_result" >&2
            echo "reason_code=profile_load_failed"
            exit 21
        }
        # Provider may have been set by profile
        if [[ -z "$PROVIDER" ]]; then
            PROVIDER="${PROFILE_CONFIG[provider_name]:-}"
            [[ -n "$PROVIDER" ]] || { echo "profile did not specify provider" >&2; exit 2; }
        fi
        echo "profile: $PROFILE -> provider: $PROVIDER" >&2
    fi
    
    [[ -n "$PROVIDER" ]] || { echo "start requires --provider or --profile" >&2; exit 2; }
    
    local adapter="${ADAPTERS_DIR}/${PROVIDER}.sh"
    [[ -f "$adapter" ]] || { echo "provider adapter not found: $adapter" >&2; exit 20; }
    
    job_paths "$BEADS" "$PROVIDER"
    
    local state
    state="$(job_state "$PID_FILE")"
    if [[ "$state" == "running" ]]; then
        echo "job $BEADS already running (pid=$(cat "$PID_FILE"))" >&2
        exit 1
    fi

    local provider_cap provider_running
    provider_cap="$(provider_max_parallel "$PROVIDER")"
    provider_running="$(provider_running_count "$PROVIDER")"
    if [[ "$provider_running" -ge "$provider_cap" ]]; then
        local msg
        msg="provider '$PROVIDER' concurrency cap exceeded (${provider_running}/${provider_cap})"
        echo "reason_code=provider_concurrency_cap_exceeded"
        echo "next_action=wait_for_provider_capacity_or_switch_provider"
        echo "$msg" >&2
        exit 26
    fi
    
    # Preflight gate
    if ! unified_preflight "$PROVIDER"; then
        echo "preflight gate failed for provider $PROVIDER" >&2
        exit 21
    fi

    # Resolve and pin worktree to avoid cwd drift/external_directory failures.
    if [[ "$PROVIDER" == "opencode" || -n "$WORKTREE" ]]; then
        WORKTREE="$(resolve_worktree "$BEADS" "$WORKTREE")"
        [[ -d "$WORKTREE" ]] || { echo "worktree not found: $WORKTREE" >&2; exit 22; }

        # Permission gate (bd-cbsb.16)
        local perm_result
        perm_result="$(check_permission_gate "$BEADS" "$WORKTREE")"
        if [[ "$perm_result" != OK* ]]; then
            echo "permission gate failed: $perm_result" >&2
            exit 22
        fi
        
        # bd-8wdg.11: Auto-remediate mise trust with proper status reporting
        if [[ "${DX_RUNNER_AUTO_TRUST_MISE:-1}" == "1" ]] && command -v mise >/dev/null 2>&1; then
            local trust_before trust_after
            trust_before="$(mise trust --show 2>/dev/null || true)"
            if [[ -z "$trust_before" ]]; then
                mise trust "$WORKTREE" >/dev/null 2>&1 || true
                trust_after="$(mise trust --show 2>/dev/null || true)"
                if [[ -n "$trust_after" ]]; then
                    echo "[bd-8wdg.11] mise trust auto-remediated for $WORKTREE" >&2
                else
                    echo "[bd-8wdg.11] WARN: mise trust auto-remediation failed for $WORKTREE" >&2
                fi
            fi
        fi
    fi
    
    # Baseline gate (optional)
    if [[ -n "$REQUIRED_BASELINE" ]]; then
        local gate_worktree gate_result gate_pass
        gate_worktree="$(resolve_worktree "$BEADS" "$WORKTREE")"
        gate_result="$(baseline_gate_eval "$gate_worktree" "$REQUIRED_BASELINE")"
        IFS='|' read -r gate_pass _ _ _ _ <<< "$gate_result"
        if [[ "$gate_pass" != "true" ]]; then
            echo "baseline gate failed: $gate_result" >&2
            exit 1
        fi
    fi
    
    # bd-8wdg.5: Scope guard (optional)
    if [[ -n "$ALLOWED_PATHS_FILE" || -n "$MUTATION_BUDGET" ]]; then
        local scope_result scope_pass scope_reason
        scope_result="$(scope_guard_eval "${WORKTREE:-$(pwd)}" "$ALLOWED_PATHS_FILE" "$MUTATION_BUDGET")"
        IFS='|' read -r scope_pass scope_reason _ _ _ <<< "$scope_result"
        if [[ "$scope_pass" != "true" ]]; then
            echo "scope guard failed: $scope_result" >&2
            echo "reason_code=$scope_reason"
            exit 29
        fi
    fi

    local run_instance
    run_instance="$(date +%Y%m%d%H%M%S)-${PROVIDER}-$$"
    local host
    host="$(host_short)"
    local cwd
    cwd="$(pwd)"
    local switched_from=""
    local start_head_commit=""
    if [[ -n "$WORKTREE" ]] && git -C "$WORKTREE" rev-parse --git-dir >/dev/null 2>&1; then
        start_head_commit="$(git -C "$WORKTREE" rev-parse HEAD 2>/dev/null || true)"
    fi
    local existing_provider
    while IFS= read -r existing_provider; do
        [[ -n "$existing_provider" ]] || continue
        if [[ "$existing_provider" != "$PROVIDER" ]]; then
            switched_from="${switched_from:+$switched_from,}${existing_provider}"
        fi
    done < <(list_providers_for_beads "$BEADS" 2>/dev/null || true)
    
    rotate_log "$LOG_FILE"
    rotate_outcome "$OUTCOME_FILE"
    
    cat > "$META_FILE" <<EOF
beads=$BEADS
provider=$PROVIDER
repo=$REPO
worktree=$WORKTREE
prompt_file=$PROMPT_FILE
started_at=$(now_utc)
retries=0
use_pty=$USE_PTY
version=$RUNNER_VERSION
run_instance=$run_instance
host=$host
cwd=$cwd
provider_switch_from=${switched_from:-none}
require_commit_artifact=${REQUIRE_COMMIT_ARTIFACT}
start_head_commit=${start_head_commit:-none}
profile=${PROFILE:-none}
model_override_allowed=${ALLOW_MODEL_OVERRIDE:-0}
allowed_paths_file=${ALLOWED_PATHS_FILE:-none}
mutation_budget=${MUTATION_BUDGET:-none}
EOF
start_head_commit=${start_head_commit:-none}
EOF

    if [[ -n "$switched_from" ]]; then
        echo "provider switch detected for beads=$BEADS: ${switched_from} -> ${PROVIDER}" >&2
    fi
    
    # Source adapter and run
    source "$adapter"
    
    if ! declare -f adapter_start >/dev/null 2>&1; then
        echo "adapter_start not found in $adapter" >&2
        exit 20
    fi
    
    local launch_output_file
    launch_output_file="$(mktemp)"
    if ! DX_RUNNER_RC_FILE="$RC_FILE" adapter_start "$BEADS" "$PROMPT_FILE" "$WORKTREE" "$LOG_FILE" >"$launch_output_file"; then
        local adapter_rc
        adapter_rc=$?
        local start_reason=""
        start_reason="$(awk -F= '/^reason_code=/{v=$2} END{print v}' "$launch_output_file" 2>/dev/null || true)"
        [[ -z "$start_reason" && "$PROVIDER" == "opencode" && "$adapter_rc" -eq 25 ]] && start_reason="opencode_model_unavailable"
        rm -f "$launch_output_file"

        if [[ -n "$start_reason" ]]; then
            persist_outcome "$BEADS" "$adapter_rc" "$OUTCOME_FILE" "$META_FILE" "$start_reason"
            echo "provider start failed for $BEADS/$PROVIDER (reason_code=$start_reason)" >&2
            [[ "$start_reason" == "opencode_model_unavailable" ]] && exit 25
            [[ "$start_reason" == "opencode_attach_mode_unavailable" || "$start_reason" == "opencode_attach_missing_url" ]] && exit 27
        fi

        echo "provider start failed for $BEADS/$PROVIDER" >&2
        exit 1
    fi
    local pid="" selected_model="" fallback_reason="" launch_mode="" adapter_rc_file=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^pid= ]]; then
            pid="${line#pid=}"
        elif [[ "$line" =~ ^selected_model= ]]; then
            selected_model="${line#selected_model=}"
        elif [[ "$line" =~ ^fallback_reason= ]]; then
            fallback_reason="${line#fallback_reason=}"
        elif [[ "$line" =~ ^launch_mode= ]]; then
            launch_mode="${line#launch_mode=}"
        elif [[ "$line" =~ ^rc_file= ]]; then
            adapter_rc_file="${line#rc_file=}"
        elif [[ "$line" =~ ^[0-9]+$ ]]; then
            pid="$line"
        fi
    done < "$launch_output_file"
    rm -f "$launch_output_file"
    [[ -n "$pid" ]] || { echo "adapter did not return pid" >&2; exit 1; }
    disown "$pid" 2>/dev/null || true
    
    echo "$pid" > "$PID_FILE"
    meta_set "$META_FILE" "pid" "$pid"
    selected_model="${selected_model:-${PROVIDER_DEFAULT_MODEL[$PROVIDER]:-unknown}}"
    meta_set "$META_FILE" "selected_model" "$selected_model"
    meta_set "$META_FILE" "model" "$selected_model"
    meta_set "$META_FILE" "fallback_reason" "${fallback_reason:-none}"
    if [[ -n "$launch_mode" ]]; then
        meta_set "$META_FILE" "launch_mode" "$launch_mode"
    fi
    if [[ -n "$adapter_rc_file" ]]; then
        RC_FILE="$adapter_rc_file"
        meta_set "$META_FILE" "rc_file" "$adapter_rc_file"
    fi
    
    persist_contract "$BEADS" "$PROVIDER" "$CONTRACT_FILE"
    
    # Initial heartbeat
    write_heartbeat "$BEADS" "$PROVIDER" "start" "job launched"
    start_completion_monitor "$BEADS" "$PROVIDER" "$pid" "$META_FILE" "$OUTCOME_FILE" "$RC_FILE" "$PID_FILE" "$LOG_FILE"
    
    echo "started beads=$BEADS provider=$PROVIDER pid=$pid log=$LOG_FILE"
}

status_line() {
    local beads="$1"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"
    prune_job "$beads" "$provider" >/dev/null
    
    local pid="" state="missing" reason="-" log_bytes="0" last_update="-" retries="0" elapsed="-" outcome="-" duration="-" mutations="-"
    local host="-" cwd="-" worktree="-" run_instance="-"
    
    if [[ -f "$PID_FILE" ]]; then
        pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    fi
    
    local detail
    detail="$(job_health_detail "$beads" "$((STALL_MINUTES * 60))")"
    IFS='|' read -r state reason mutations log_bytes _cpu _pid_age _log_age <<< "$detail"
    
    if [[ -f "$OUTCOME_FILE" ]]; then
        local outcome_state outcome_exit outcome_duration
        outcome_state="$(meta_get "$OUTCOME_FILE" "state")"
        outcome_exit="$(meta_get "$OUTCOME_FILE" "exit_code")"
        outcome_duration="$(meta_get "$OUTCOME_FILE" "duration_sec")"
        outcome="${outcome_state:-completed}:${outcome_exit:-?}"
        if [[ -n "$outcome_duration" && "$outcome_duration" != "-" ]]; then
            outcome="${outcome} (${outcome_duration}s)"
        fi
    fi
    
    if [[ -f "$LOG_FILE" ]]; then
        local mtime now age
        mtime="$(file_mtime_epoch "$LOG_FILE" 2>/dev/null || echo "")"
        if [[ -n "$mtime" ]]; then
            now="$(date +%s)"
            age=$((now - mtime))
            last_update="$(format_elapsed "$age") ago"
        fi
    fi
    
    if [[ -f "$META_FILE" ]]; then
        retries="$(meta_get "$META_FILE" "retries")"
        [[ -n "$retries" ]] || retries="0"
        host="$(meta_get "$META_FILE" "host" 2>/dev/null || echo "-")"
        cwd="$(meta_get "$META_FILE" "cwd" 2>/dev/null || echo "-")"
        worktree="$(meta_get "$META_FILE" "worktree" 2>/dev/null || echo "-")"
        run_instance="$(meta_get "$META_FILE" "run_instance" 2>/dev/null || echo "-")"
    fi
    
    if [[ -f "$PID_FILE" ]]; then
        local pid_mtime now
        pid_mtime="$(file_mtime_epoch "$PID_FILE" 2>/dev/null || echo "")"
        if [[ -n "$pid_mtime" ]]; then
            now="$(date +%s)"
            elapsed="$(format_elapsed "$((now - pid_mtime))")"
        fi
    fi
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{'
        printf '"beads":"%s",' "$(json_escape "$beads")"
        printf '"provider":"%s",' "$(json_escape "${provider:-unknown}")"
        printf '"pid":"%s",' "$(json_escape "${pid:--}")"
        printf '"state":"%s",' "$(json_escape "$state")"
        printf '"reason_code":"%s",' "$(json_escape "$reason")"
        printf '"elapsed":"%s",' "$(json_escape "$elapsed")"
        printf '"log_bytes":%s,' "${log_bytes:-0}"
        printf '"mutation_count":%s,' "${mutations:-0}"
        printf '"retry_count":%s,' "${retries:-0}"
        printf '"host":"%s",' "$(json_escape "$host")"
        printf '"cwd":"%s",' "$(json_escape "$cwd")"
        printf '"worktree":"%s",' "$(json_escape "$worktree")"
        printf '"run_instance":"%s",' "$(json_escape "$run_instance")"
        printf '"outcome":"%s"' "$(json_escape "$outcome")"
        printf '}\n'
        return 0
    fi
    
    printf "%-14s %-10s %-8s %-14s %-12s %-9s %-6s %s\n" \
        "$beads" "${provider:-?}" "${pid:--}" "$state" "$elapsed" "$log_bytes" "$retries" "$outcome"
}

status_cmd() {
    parse_common_args "$@"
    
    local active_rows=()
    local recent_rows=()
    
    shopt -s nullglob
    
    # Collect active jobs
    for dir in /tmp/dx-runner/*/; do
        [[ -d "$dir" ]] || continue
        for pidf in "$dir"/*.pid; do
            local beads
            beads="$(basename "$pidf" .pid)"
            [[ "$beads" == *.monitor ]] && continue
            active_rows+=("$(status_line "$beads")")
        done
    done
    for pidf in /tmp/dx-runner/*.pid; do
        local beads
        beads="$(basename "$pidf" .pid)"
        [[ "$beads" == *.monitor ]] && continue
        active_rows+=("$(status_line "$beads")")
    done
    
    # Collect and sort recent jobs by completion time
    if [[ "$RECENT_COUNT" -gt 0 ]]; then
        local recent_with_mtime=()
        for dir in /tmp/dx-runner/*/; do
            [[ -d "$dir" ]] || continue
            for outcomef in "$dir"/*.outcome; do
                local beads mtime
                beads="$(basename "$outcomef" .outcome)"
                [[ -f "${dir}${beads}.pid" ]] && continue
                mtime="$(file_mtime_epoch "$outcomef" 2>/dev/null || echo "0")"
                recent_with_mtime+=("${mtime}|${beads}")
            done
        done
        for outcomef in /tmp/dx-runner/*.outcome; do
            local beads mtime already_seen
            beads="$(basename "$outcomef" .outcome)"
            [[ -f "/tmp/dx-runner/${beads}.pid" ]] && continue
            already_seen=0
            for entry in "${recent_with_mtime[@]}"; do
                [[ "${entry##*|}" == "$beads" ]] && already_seen=1 && break
            done
            [[ "$already_seen" -eq 1 ]] && continue
            mtime="$(file_mtime_epoch "$outcomef" 2>/dev/null || echo "0")"
            recent_with_mtime+=("${mtime}|${beads}")
        done
        
        # Sort by mtime descending (newest first), then dedupe by beads (keep newest), then take top N.
        local sorted_recent
        if [[ ${#recent_with_mtime[@]} -gt 0 ]]; then
            mapfile -t sorted_recent < <(
                printf '%s\n' "${recent_with_mtime[@]}" \
                    | sort -t'|' -k1 -rn \
                    | awk -F'|' '!seen[$2]++ {print $0}' \
                    | head -n "$RECENT_COUNT"
            )
            for entry in "${sorted_recent[@]}"; do
                local beads="${entry##*|}"
                recent_rows+=("$(status_line "$beads")")
            done
        fi
    fi
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        if [[ -n "$BEADS" ]]; then
            printf '{"generated_at":"%s","jobs":[%s]}\n' "$(now_utc)" "$(status_line "$BEADS")"
            return 0
        fi
        local all_rows=("${active_rows[@]}")
        all_rows+=("${recent_rows[@]}")
        printf '{"generated_at":"%s","jobs":[%s]}\n' "$(now_utc)" "$(join_by "," "${all_rows[@]}")"
        return 0
    fi
    
    printf "%-14s %-10s %-8s %-14s %-12s %-9s %-6s %s\n" \
        "bead" "provider" "pid" "state" "elapsed" "bytes" "retry" "outcome"
    
    if [[ -n "$BEADS" ]]; then
        status_line "$BEADS"
        return 0
    fi
    
    for row in "${active_rows[@]}"; do
        echo "$row"
    done
    
    if [[ ${#recent_rows[@]} -gt 0 ]]; then
        echo ""
        echo "=== Recently Completed (last $RECENT_COUNT) ==="
        for row in "${recent_rows[@]}"; do
            echo "$row"
        done
    fi
    
    if [[ ${#active_rows[@]} -eq 0 && ${#recent_rows[@]} -eq 0 ]]; then
        echo "(no jobs found in /tmp/dx-runner)"
    fi
}

check_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "check requires --beads" >&2; exit 2; }
    
    local provider
    provider="$(find_provider_for_beads "$BEADS")"
    
    if [[ -z "$provider" ]]; then
        for dir in /tmp/dx-runner/*/; do
            [[ -d "$dir" ]] || continue
            if [[ -f "${dir}${BEADS}.meta" ]]; then
                provider="$(basename "$dir")"
                break
            fi
        done
    fi
    
    job_paths "$BEADS" "$provider"
    prune_job "$BEADS" "$provider" >/dev/null
    
    if [[ ! -f "$META_FILE" ]]; then
        echo "job $BEADS has no metadata file"
        [[ "$OUTPUT_JSON" == "true" ]] && printf '{"beads":"%s","state":"missing","reason_code":"no_meta"}\n' "$BEADS"
        exit 1
    fi
    
    local detail state reason mutation_count log_bytes cpu_time pid_age log_age
    detail="$(job_health_detail "$BEADS" "$((STALL_MINUTES * 60))")"
    IFS='|' read -r state reason mutation_count log_bytes cpu_time pid_age log_age <<< "$detail"
    [[ "$mutation_count" =~ ^[0-9]+$ ]] || mutation_count=0
    [[ "$log_bytes" =~ ^[0-9]+$ ]] || log_bytes=0
    [[ "$cpu_time" =~ ^[0-9]+$ ]] || cpu_time=0
    [[ "$pid_age" =~ ^[0-9]+$ ]] || pid_age=0
    [[ "$log_age" =~ ^[0-9]+$ ]] || log_age=0
    
    # bd-8wdg.3: Reason already comes from outcome in job_health_detail for finalized jobs
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        local j_host j_cwd j_worktree j_run_instance j_model j_fallback j_profile
        local j_action
        j_host="$(meta_get "$META_FILE" "host" 2>/dev/null || echo "-")"
        j_cwd="$(meta_get "$META_FILE" "cwd" 2>/dev/null || echo "-")"
        j_worktree="$(meta_get "$META_FILE" "worktree" 2>/dev/null || echo "-")"
        j_run_instance="$(meta_get "$META_FILE" "run_instance" 2>/dev/null || echo "-")"
        j_model="$(meta_get "$META_FILE" "selected_model" 2>/dev/null || echo "-")"
        j_fallback="$(meta_get "$META_FILE" "fallback_reason" 2>/dev/null || echo "-")"
        j_profile="$(meta_get "$META_FILE" "profile" 2>/dev/null || echo "-")"
        if [[ -f "$OUTCOME_FILE" ]]; then
            j_model="$(meta_get "$OUTCOME_FILE" "selected_model" 2>/dev/null || echo "$j_model")"
            j_fallback="$(meta_get "$OUTCOME_FILE" "fallback_reason" 2>/dev/null || echo "$j_fallback")"
        fi
        j_action="$(next_action_for_reason "$reason")"
        printf '{"beads":"%s","provider":"%s","state":"%s","reason_code":"%s","next_action":"%s","host":"%s","cwd":"%s","worktree":"%s","run_instance":"%s","selected_model":"%s","fallback_reason":"%s","profile":"%s","mutation_count":%s,"log_bytes":%s,"cpu_time_sec":%s,"pid_age_sec":%s,"log_age_sec":%s}\n' \
            "$BEADS" "${provider:-unknown}" "$state" "$reason" "$j_action" "$(json_escape "$j_host")" "$(json_escape "$j_cwd")" "$(json_escape "$j_worktree")" "$(json_escape "$j_run_instance")" "$(json_escape "$j_model")" "$(json_escape "$j_fallback")" "$(json_escape "$j_profile")" "$mutation_count" "$log_bytes" "$cpu_time" "$pid_age" "$log_age"
    else
        echo "$BEADS: $state ($reason)"
        local action
        action="$(next_action_for_reason "$reason")"
        if [[ "$action" != "-" ]]; then
            echo "next_action=$action"
        fi
        echo "selected_model=$(meta_get "$META_FILE" "selected_model" 2>/dev/null || echo -)"
        echo "metrics mutations=$mutation_count log_bytes=$log_bytes cpu_time_sec=$cpu_time pid_age_sec=$pid_age log_age_sec=$log_age"
    fi
    
    # bd-8wdg.3: Handle stopped state explicitly
    case "$state" in
        stalled) exit 2 ;;
        no_op) exit 23 ;;
        exited_err) exit 3 ;;
        stopped) exit 0 ;;  # Manual stop is not an error
        blocked) exit 3 ;;
        exited_ok) exit 0 ;;
        slow_start) exit 0 ;;  # bd-8wdg.10: Slow start is not stalled
        *) exit 0 ;;
    esac
}

stop_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "stop requires --beads" >&2; exit 2; }
    
    local provider
    provider="$(find_provider_for_beads "$BEADS")"
    job_paths "$BEADS" "$provider"
    
    if [[ ! -f "$PID_FILE" && ! -f "$MONITOR_PID_FILE" ]]; then
        echo "job $BEADS has no active process or monitor"
        exit 1
    fi
    
    # bd-8wdg.3: Record metrics before stopping
    local snap_mutations=0 snap_log_bytes=0 snap_cpu=0 snap_pid_age=0
    if [[ -f "$LOG_FILE" ]]; then
        snap_log_bytes="$(wc -c < "$LOG_FILE" 2>/dev/null | tr -d ' ')" || snap_log_bytes=0
    fi
    if [[ -f "$META_FILE" ]]; then
        snap_mutations="$(check_mutations "$BEADS" 2>/dev/null || echo 0)"
        snap_cpu="$(meta_get "$META_FILE" "last_cpu_time" 2>/dev/null || echo 0)"
    fi
    if [[ -f "$PID_FILE" ]]; then
        local now pid_mtime
        now="$(date +%s)"
        pid_mtime="$(file_mtime_epoch "$PID_FILE" 2>/dev/null || echo "$now")"
        snap_pid_age=$((now - pid_mtime))
    fi
    
    stop_job_internal "$BEADS" "$provider"
    
    # bd-8wdg.3: Persist outcome with manual_stop reason and captured metrics
    persist_outcome "$BEADS" 137 "$OUTCOME_FILE" "$META_FILE" "manual_stop"
    
    # Append metrics to outcome for consistency
    if [[ -f "$OUTCOME_FILE" ]]; then
        meta_set "$OUTCOME_FILE" "mutations" "$snap_mutations"
        meta_set "$OUTCOME_FILE" "log_bytes" "$snap_log_bytes"
        meta_set "$OUTCOME_FILE" "cpu_time_sec" "$snap_cpu"
        meta_set "$OUTCOME_FILE" "pid_age_sec" "$snap_pid_age"
    fi
    
    echo "stopped beads=$BEADS reason_code=manual_stop"
}

compact_log_filter() {
    local filter_json_payloads="${1:-true}"
    
    while IFS= read -r line; do
        if [[ "$filter_json_payloads" == "true" ]] && [[ "$line" =~ ^\{.*\}$ ]] && [[ ${#line} -gt 500 ]]; then
            local msg_type=""
            msg_type="$(echo "$line" | jq -r '.type // .kind // "unknown"' 2>/dev/null || echo "unknown")"
            case "$msg_type" in
                assistant|user|system)
                    local content_preview
                    content_preview="$(echo "$line" | jq -r '.content // .message // .text // ""' 2>/dev/null | head -c 100)"
                    echo "[${msg_type}] ${content_preview}... (truncated ${#line} bytes)"
                    ;;
                tool_use|tool_result)
                    local tool_name
                    tool_name="$(echo "$line" | jq -r '.name // .tool_name // "unknown"' 2>/dev/null)"
                    echo "[tool:${tool_name}] (truncated ${#line} bytes)"
                    ;;
                error|ERROR)
                    echo "$line"
                    ;;
                *)
                    echo "[json:${msg_type}] (${#line} bytes)"
                    ;;
            esac
        else
            echo "$line"
        fi
    done
}

logs_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "logs requires --beads" >&2; exit 2; }
    
    local provider
    provider="$(find_provider_for_beads "$BEADS")"
    job_paths "$BEADS" "$provider"
    
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "no log file for $BEADS"
        exit 1
    fi
    
    local lines="${TAIL_LINES:-50}"
    local compact="${COMPACT_LOGS:-false}"
    
    if [[ "$compact" == "true" ]]; then
        tail -n "$lines" "$LOG_FILE" | compact_log_filter "true"
    else
        tail -n "$lines" "$LOG_FILE"
    fi
}

prune_cmd() {
    parse_common_args "$@"
    local checked=0
    local pruned=0

    if [[ -n "$BEADS" ]]; then
        local provider
        provider="$(find_provider_for_beads "$BEADS")"
        checked=1
        pruned="$((pruned + $(prune_job "$BEADS" "$provider")))"
    else
        shopt -s nullglob
        for pidf in /tmp/dx-runner/*/*.pid /tmp/dx-runner/*.pid; do
            [[ -f "$pidf" ]] || continue
            local beads provider
            beads="$(basename "$pidf" .pid)"
            [[ "$beads" == *.monitor ]] && continue
            provider="$(find_provider_for_beads "$beads")"
            checked=$((checked + 1))
            pruned="$((pruned + $(prune_job "$beads" "$provider")))"
        done
    fi

    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"checked":%s,"pruned":%s}\n' "$checked" "$pruned"
    else
        echo "prune: checked=$checked pruned=$pruned"
    fi
}

restart_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "restart requires --beads" >&2; exit 2; }
    
    local provider worktree prompt_file
    provider="$(find_provider_for_beads "$BEADS")"
    job_paths "$BEADS" "$provider"
    
    if [[ ! -f "$META_FILE" ]]; then
        echo "job $BEADS has no metadata file"
        exit 1
    fi
    
    worktree="$(meta_get "$META_FILE" "worktree")"
    prompt_file="$(meta_get "$META_FILE" "prompt_file")"
    
    # Increment retry count
    local retries
    retries="$(meta_get "$META_FILE" "retries")"
    retries="${retries:-0}"
    retries=$((retries + 1))
    meta_set "$META_FILE" "retries" "$retries"
    meta_set "$META_FILE" "run_instance" "$(date +%Y%m%d%H%M%S)-${provider}-$$"
    meta_set "$META_FILE" "host" "$(host_short)"
    meta_set "$META_FILE" "cwd" "$(pwd)"
    
    # Stop existing
    stop_job_internal "$BEADS" "$provider"
    
    # Rotate logs
    rotate_log "$LOG_FILE"
    rotate_outcome "$OUTCOME_FILE"
    
    # Source adapter and restart
    local adapter="${ADAPTERS_DIR}/${provider}.sh"
    if [[ ! -f "$adapter" ]]; then
        echo "provider adapter not found: $adapter" >&2
        exit 20
    fi
    
    source "$adapter"
    
    local launch_output_file
    launch_output_file="$(mktemp)"
    if ! DX_RUNNER_RC_FILE="$RC_FILE" adapter_start "$BEADS" "$prompt_file" "$worktree" "$LOG_FILE" >"$launch_output_file"; then
        rm -f "$launch_output_file"
        echo "provider restart failed for $BEADS/$provider" >&2
        exit 1
    fi
    local pid="" selected_model="" fallback_reason="" launch_mode="" adapter_rc_file=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^pid= ]]; then
            pid="${line#pid=}"
        elif [[ "$line" =~ ^selected_model= ]]; then
            selected_model="${line#selected_model=}"
        elif [[ "$line" =~ ^fallback_reason= ]]; then
            fallback_reason="${line#fallback_reason=}"
        elif [[ "$line" =~ ^launch_mode= ]]; then
            launch_mode="${line#launch_mode=}"
        elif [[ "$line" =~ ^rc_file= ]]; then
            adapter_rc_file="${line#rc_file=}"
        elif [[ "$line" =~ ^[0-9]+$ ]]; then
            pid="$line"
        fi
    done < "$launch_output_file"
    rm -f "$launch_output_file"
    [[ -n "$pid" ]] || { echo "adapter did not return pid on restart" >&2; exit 1; }
    disown "$pid" 2>/dev/null || true

    echo "$pid" > "$PID_FILE"
    meta_set "$META_FILE" "pid" "$pid"
    selected_model="${selected_model:-${PROVIDER_DEFAULT_MODEL[$provider]:-unknown}}"
    meta_set "$META_FILE" "selected_model" "$selected_model"
    meta_set "$META_FILE" "model" "$selected_model"
    meta_set "$META_FILE" "fallback_reason" "${fallback_reason:-none}"
    if [[ -n "$launch_mode" ]]; then
        meta_set "$META_FILE" "launch_mode" "$launch_mode"
    fi
    if [[ -n "$adapter_rc_file" ]]; then
        RC_FILE="$adapter_rc_file"
        meta_set "$META_FILE" "rc_file" "$adapter_rc_file"
    fi
    
    write_heartbeat "$BEADS" "$provider" "restart" "job restarted (retry $retries)"
    start_completion_monitor "$BEADS" "$provider" "$pid" "$META_FILE" "$OUTCOME_FILE" "$RC_FILE" "$PID_FILE" "$LOG_FILE"
    
    echo "restarted beads=$BEADS provider=$provider pid=$pid retry=$retries"
}

report_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "report requires --beads" >&2; exit 2; }
    
    local provider
    provider="$(find_provider_for_beads "$BEADS")"
    job_paths "$BEADS" "$provider"
    
    local detail state reason mutations log_bytes cpu_time pid_age log_age
    detail="$(job_health_detail "$BEADS")"
    IFS='|' read -r state reason mutations log_bytes cpu_time pid_age log_age <<< "$detail"
    [[ "$mutations" =~ ^[0-9]+$ ]] || mutations=0
    [[ "$log_bytes" =~ ^[0-9]+$ ]] || log_bytes=0
    [[ "$cpu_time" =~ ^[0-9]+$ ]] || cpu_time=0
    [[ "$pid_age" =~ ^[0-9]+$ ]] || pid_age=0
    
    local retries="0" started_at="-" worktree="-" prompt_file="-" exit_code="-" duration="-" outcome_state="-" outcome_reason="-" selected_model="-" fallback_reason="-"
    local host="-" cwd="-" run_instance="-" next_action="-" reported_commit="-" require_commit_artifact="0"
    
    if [[ -f "$META_FILE" ]]; then
        retries="$(meta_get "$META_FILE" "retries")"
        started_at="$(meta_get "$META_FILE" "started_at")"
        worktree="$(meta_get "$META_FILE" "worktree")"
        prompt_file="$(meta_get "$META_FILE" "prompt_file")"
        selected_model="$(meta_get "$META_FILE" "selected_model")"
        fallback_reason="$(meta_get "$META_FILE" "fallback_reason")"
        host="$(meta_get "$META_FILE" "host")"
        cwd="$(meta_get "$META_FILE" "cwd")"
        run_instance="$(meta_get "$META_FILE" "run_instance")"
        require_commit_artifact="$(meta_get "$META_FILE" "require_commit_artifact" 2>/dev/null || echo "0")"
        reported_commit="$(meta_get "$META_FILE" "reported_commit" 2>/dev/null || echo "-")"
    fi
    
    if [[ -f "$OUTCOME_FILE" ]]; then
        exit_code="$(meta_get "$OUTCOME_FILE" "exit_code")"
        duration="$(meta_get "$OUTCOME_FILE" "duration_sec")"
        outcome_state="$(meta_get "$OUTCOME_FILE" "state")"
        outcome_reason="$(meta_get "$OUTCOME_FILE" "reason_code")"
        selected_model="$(meta_get "$OUTCOME_FILE" "selected_model")"
        fallback_reason="$(meta_get "$OUTCOME_FILE" "fallback_reason")"
        host="$(meta_get "$OUTCOME_FILE" "host")"
        cwd="$(meta_get "$OUTCOME_FILE" "cwd")"
        worktree="$(meta_get "$OUTCOME_FILE" "worktree")"
        run_instance="$(meta_get "$OUTCOME_FILE" "run_instance")"
        reported_commit="$(meta_get "$OUTCOME_FILE" "reported_commit" 2>/dev/null || echo "$reported_commit")"
    fi
    [[ "$retries" =~ ^[0-9]+$ ]] || retries="0"
    [[ -n "$duration" ]] || duration="-"
    [[ -n "$host" ]] || host="-"
    [[ -n "$cwd" ]] || cwd="-"
    [[ -n "$worktree" ]] || worktree="-"
    [[ -n "$run_instance" ]] || run_instance="-"
    next_action="$(next_action_for_reason "${outcome_reason:-$reason}")"
    
    if [[ "$REPORT_FORMAT" == "json" || "$OUTPUT_JSON" == "true" ]]; then
        cat <<EOF
{
  "beads": "$BEADS",
  "provider": "${provider:-unknown}",
  "state": "$state",
  "reason_code": "$reason",
  "started_at": "$started_at",
  "duration_sec": "$duration",
  "retries": $retries,
  "exit_code": "${exit_code:--}",
  "outcome_state": "${outcome_state:--}",
  "outcome_reason_code": "${outcome_reason:--}",
  "selected_model": "${selected_model:--}",
  "fallback_reason": "${fallback_reason:--}",
  "reported_commit": "${reported_commit:--}",
  "require_commit_artifact": ${require_commit_artifact:-0},
  "next_action": "${next_action:--}",
  "host": "${host:--}",
  "cwd": "${cwd:--}",
  "run_instance": "${run_instance:--}",
  "worktree": "${worktree:--}",
  "mutations": $mutations,
  "log_bytes": $log_bytes,
  "cpu_time_sec": $cpu_time,
  "pid_age_sec": $pid_age
}
EOF
    else
        cat <<EOF
# Report: $BEADS

## Summary
- Provider: ${provider:-unknown}
- State: $state
- Reason: $reason
- Started: $started_at
- Duration: ${duration}s
- Retries: $retries

## Outcome
- Exit Code: ${exit_code:--}
- State: ${outcome_state:--}
- Reason: ${outcome_reason:--}
- Selected Model: ${selected_model:--}
- Fallback Reason: ${fallback_reason:--}
- Reported Commit: ${reported_commit:--}
- Require Commit Artifact: ${require_commit_artifact:-0}
- Next Action: ${next_action:--}

## Metrics
- Host: ${host:--}
- CWD: ${cwd:--}
- Run Instance: ${run_instance:--}
- Worktree: ${worktree:--}
- Mutations: $mutations
- Log Size: $log_bytes bytes
- CPU Time: ${cpu_time}s
- PID Age: ${pid_age}s
EOF
    fi
}

preflight_cmd() {
    parse_common_args "$@"
    unified_preflight "$PROVIDER"
    exit $?
}

probe_cmd() {
    parse_common_args "$@"
    [[ -n "$PROVIDER" ]] || { echo "probe requires --provider" >&2; exit 2; }
    
    local adapter="${ADAPTERS_DIR}/${PROVIDER}.sh"
    if [[ ! -f "$adapter" ]]; then
        echo "provider adapter not found: $adapter" >&2
        exit 20
    fi
    
    source "$adapter"
    
    if ! declare -f adapter_probe_model >/dev/null 2>&1; then
        echo "adapter_probe_model not implemented for $PROVIDER" >&2
        exit 1
    fi
    
    local model="${MODEL_ID:-${PROVIDER_DEFAULT_MODEL[$PROVIDER]:-}}"
    local probe_rc=0
    
    echo "Probing $PROVIDER with model $model..."
    if [[ "$PROVIDER" == "opencode" ]]; then
        OPENCODE_MODELS_CACHE_TTL_SEC=0 adapter_probe_model "$model" || probe_rc=$?
    else
        adapter_probe_model "$model" || probe_rc=$?
    fi
    if [[ "$probe_rc" -eq 0 ]]; then
        echo "OK: $PROVIDER/$model is healthy"
        exit 0
    else
        echo "FAILED: $PROVIDER/$model is not responding"
        exit 1
    fi
}

watchdog_cmd() {
    parse_common_args "$@"
    
    echo "Starting watchdog (interval=${WATCHDOG_INTERVAL}s, max_retries=${WATCHDOG_MAX_RETRIES}, max_runtime=${MAX_RUNTIME_MINUTES}m, no_mut_timeout=${NO_MUTATION_TIMEOUT_MINUTES}m)..."
    
    while true; do
        shopt -s nullglob
        
        for pidf in /tmp/dx-runner/*.pid /tmp/dx-runner/*/*.pid; do
            [[ -f "$pidf" ]] || continue
            local beads
            beads="$(basename "$pidf" .pid)"
            [[ "$beads" == *.monitor ]] && continue
            
            local provider
            provider="$(find_provider_for_beads "$beads")"
            job_paths "$beads" "$provider"
            
            local detail state reason
            detail="$(job_health_detail "$beads" "$((STALL_MINUTES * 60))")"
            IFS='|' read -r state reason _ _ _ _ _ <<< "$detail"
            
            echo "$(now_utc) [$beads] $state ($reason)"
            
            local timeout_result=""
            timeout_result="$(check_timeout_conditions "$beads" 2>/dev/null)" || true
            if [[ -n "$timeout_result" ]]; then
                local timeout_type timeout_val timeout_thresh
                IFS='|' read -r timeout_type timeout_val timeout_thresh <<< "$timeout_result"
                echo "$(now_utc) [$beads] TIMEOUT: $timeout_type (${timeout_val}s > ${timeout_thresh}s)"
                
                local retries
                retries="$(meta_get "$META_FILE" "retries")"
                retries="${retries:-0}"
                
                if [[ "$retries" -lt "$WATCHDOG_MAX_RETRIES" ]]; then
                    echo "$(now_utc) [$beads] force finalizing due to $timeout_type"
                    force_finalize_job "$beads" "$provider" "$timeout_type" 124
                else
                    echo "$(now_utc) [$beads] marking as blocked (max retries reached)"
                    meta_set "$META_FILE" "blocked" "true"
                    force_finalize_job "$beads" "$provider" "blocked_${timeout_type}" 1
                fi
                continue
            fi
            
            if [[ "$state" == "stalled" || "$state" == "no_op" ]]; then
                local retries
                retries="$(meta_get "$META_FILE" "retries")"
                retries="${retries:-0}"
                
                if [[ "$retries" -lt "$WATCHDOG_MAX_RETRIES" ]]; then
                    echo "$(now_utc) [$beads] restarting (retry $((retries + 1))/$WATCHDOG_MAX_RETRIES)"
                    BEADS="$beads" restart_cmd
                else
                    echo "$(now_utc) [$beads] marking as blocked (max retries reached)"
                    meta_set "$META_FILE" "blocked" "true"
                fi
            fi
        done
        
        sleep "$WATCHDOG_INTERVAL"
    done
}

# Gate commands
baseline_gate_cmd() {
    parse_common_args "$@"
    local worktree
    worktree="$(resolve_worktree "$BEADS" "$WORKTREE")"
    
    [[ -n "$REQUIRED_BASELINE" ]] || { echo "baseline-gate requires --required-baseline" >&2; exit 2; }
    
    local result gate_pass gate_reason gate_runtime gate_required gate_details
    result="$(baseline_gate_eval "$worktree" "$REQUIRED_BASELINE")"
    IFS='|' read -r gate_pass gate_reason gate_runtime gate_required gate_details <<< "$result"
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","runtime":"%s","required":"%s","details":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_runtime" "$gate_required" "$(json_escape "$gate_details")"
    else
        echo "Baseline Gate: $gate_pass ($gate_reason)"
        echo "  Runtime: $gate_runtime"
        echo "  Required: $gate_required"
        echo "  Details: $gate_details"
    fi
    
    [[ "$gate_pass" == "true" ]] || exit 1
}

integrity_gate_cmd() {
    parse_common_args "$@"
    local worktree
    worktree="$(resolve_worktree "$BEADS" "$WORKTREE")"
    
    [[ -n "$REPORTED_COMMIT" ]] || { echo "integrity-gate requires --reported-commit" >&2; exit 2; }
    
    local result gate_pass gate_reason gate_branch gate_head gate_reported gate_details
    result="$(integrity_gate_eval "$worktree" "$REPORTED_COMMIT" "$BRANCH_NAME")"
    IFS='|' read -r gate_pass gate_reason gate_branch gate_head gate_reported gate_details <<< "$result"
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","branch":"%s","head":"%s","reported":"%s","details":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_branch" "$gate_head" "$gate_reported" "$(json_escape "$gate_details")"
    else
        echo "Integrity Gate: $gate_pass ($gate_reason)"
        echo "  Branch: $gate_branch"
        echo "  Head: $gate_head"
        echo "  Reported: $gate_reported"
        echo "  Details: $gate_details"
    fi
    
    [[ "$gate_pass" == "true" ]] || exit 1
}

feature_key_gate_cmd() {
    parse_common_args "$@"
    local worktree
    worktree="$(resolve_worktree "$BEADS" "$WORKTREE")"
    
    [[ -n "$FEATURE_KEY" ]] || { echo "feature-key-gate requires --feature-key" >&2; exit 2; }
    
    local result gate_pass gate_reason gate_branch gate_base gate_fk gate_checked gate_details
    result="$(feature_key_gate_eval "$worktree" "$FEATURE_KEY" "$BRANCH_NAME" "$BASE_BRANCH")"
    IFS='|' read -r gate_pass gate_reason gate_branch gate_base gate_fk gate_checked gate_details <<< "$result"
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","branch":"%s","base":"%s","feature_key":"%s","checked_commits":%s,"details":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_branch" "$gate_base" "$gate_fk" "$gate_checked" "$(json_escape "$gate_details")"
    else
        echo "Feature-Key Gate: $gate_pass ($gate_reason)"
        echo "  Branch: $gate_branch"
        echo "  Base: $gate_base"
        echo "  Feature-Key: $gate_fk"
        echo "  Checked: $gate_checked commits"
        echo "  Details: $gate_details"
    fi
    
    [[ "$gate_pass" == "true" ]] || exit 1
}

# ============================================================================
# SCOPE GUARD (bd-8wdg.5)
# ============================================================================

scope_guard_eval() {
    local worktree="$1"
    local allowed_paths_file="${2:-}"
    local mutation_budget="${3:-}"
    
    local passed=true
    local reason_code="scope_ok"
    local violations=""
    local mutation_count=0
    local checked_files=0
    
    if [[ ! -d "$worktree" ]]; then
        printf '%s|%s|%s|%s|%s\n' "false" "worktree_missing" "0" "0" "Worktree not found"
        return 1
    fi
    
    # Check allowed paths if file provided
    if [[ -n "$allowed_paths_file" && -f "$allowed_paths_file" ]]; then
        local -a allowed_paths=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && allowed_paths+=("$line")
        done < "$allowed_paths_file"
        
        # Check for files modified outside allowed paths
        if git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
            while IFS= read -r file; do
                [[ -n "$file" ]] || continue
                checked_files=$((checked_files + 1))
                local allowed=false
                for allowed_path in "${allowed_paths[@]}"; do
                    if [[ "$file" == "$allowed_path"* ]]; then
                        allowed=true
                        break
                    fi
                done
                if [[ "$allowed" == false ]]; then
                    passed=false
                    reason_code="path_outside_allowlist"
                    violations="${violations}${violations:+,}$file"
                fi
            done < <(git -C "$worktree" diff --name-only HEAD~1 2>/dev/null || true)
        fi
    fi
    
    # Check mutation budget if specified
    if [[ -n "$mutation_budget" && "$mutation_budget" =~ ^[0-9]+$ ]]; then
        if git -C "$worktree" rev-parse --git-dir >/dev/null 2>&1; then
            mutation_count="$(git -C "$worktree" status --porcelain --untracked-files=all 2>/dev/null | wc -l | tr -d ' ')" || mutation_count=0
            if [[ "$mutation_count" -gt "$mutation_budget" ]]; then
                passed=false
                reason_code="mutation_budget_exceeded"
                violations="mutations=$mutation_count budget=$mutation_budget"
            fi
        fi
    fi
    
    printf '%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$mutation_count" "$checked_files" "$violations"
}

scope_gate_cmd() {
    parse_common_args "$@"
    local worktree
    worktree="$(resolve_worktree "$BEADS" "$WORKTREE")"
    
    local result gate_pass gate_reason gate_mutations gate_checked gate_violations
    result="$(scope_guard_eval "$worktree" "$ALLOWED_PATHS_FILE" "$MUTATION_BUDGET")"
    IFS='|' read -r gate_pass gate_reason gate_mutations gate_checked gate_violations <<< "$result"
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","mutations":%s,"checked_files":%s,"violations":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_mutations" "$gate_checked" "$(json_escape "$gate_violations")"
    else
        echo "Scope Gate: $gate_pass ($gate_reason)"
        echo "  Mutations: $gate_mutations"
        echo "  Checked Files: $gate_checked"
        [[ -n "$gate_violations" ]] && echo "  Violations: $gate_violations"
    fi
    
    if [[ "$gate_pass" != "true" ]]; then
        exit 29
    fi
}

# ============================================================================
# EVIDENCE TRUTHFULNESS GATE (bd-8wdg.6)
# ============================================================================

evidence_gate_eval() {
    local beads="$1"
    local signoff_file="$2"
    local provider
    provider="$(find_provider_for_beads "$beads")"
    job_paths "$beads" "$provider"
    
    local passed=true
    local reason_code="evidence_ok"
    local missing_claims=""
    local verified_claims=0
    local total_claims=0
    
    if [[ ! -f "$signoff_file" ]]; then
        printf '%s|%s|%s|%s|%s\n' "false" "signoff_file_missing" "0" "0" "Signoff file not found"
        return 1
    fi
    
    if [[ ! -f "$OUTCOME_FILE" ]]; then
        printf '%s|%s|%s|%s|%s\n' "false" "outcome_missing" "0" "0" "No outcome file for this run"
        return 1
    fi
    
    # Extract claims from signoff file (lines like "Validated: X" or "- [x] X")
    local claim_patterns=(
        "validated:"
        "- \[x\]"
        "- \[X\]"
        "VERIFIED:"
        "CONFIRMED:"
    )
    
    # Check for common unsupported claims
    local unsupported_claims=()
    while IFS= read -r line; do
        line="$(echo "$line" | tr '[:upper:]' '[:lower:]')"
        total_claims=$((total_claims + 1))
        
        # Check if claim is actually validated by outcome
        local claim_verified=false
        
        # Check for test claims
        if [[ "$line" =~ "tests pass" || "$line" =~ "all tests" ]]; then
            # Would need test results - mark as needing verification
            if [[ -f "$LOG_FILE" ]] && grep -qiE "tests?.*(pass|ok|success)" "$LOG_FILE" 2>/dev/null; then
                claim_verified=true
            fi
        fi
        
        # Check for lint claims
        if [[ "$line" =~ "lint" && "$line" =~ "pass" ]]; then
            if [[ -f "$LOG_FILE" ]] && grep -qiE "lint.*(pass|ok|clean|no errors)" "$LOG_FILE" 2>/dev/null; then
                claim_verified=true
            fi
        fi
        
        # Check for CI claims
        if [[ "$line" =~ "ci" && "$line" =~ "pass" ]]; then
            local exit_code
            exit_code="$(meta_get "$OUTCOME_FILE" "exit_code" 2>/dev/null || echo 1)"
            if [[ "$exit_code" == "0" ]]; then
                claim_verified=true
            fi
        fi
        
        if [[ "$claim_verified" == true ]]; then
            verified_claims=$((verified_claims + 1))
        else
            # Generic claim - check if outcome shows success
            local exit_code outcome_state
            exit_code="$(meta_get "$OUTCOME_FILE" "exit_code" 2>/dev/null || echo 1)"
            outcome_state="$(meta_get "$OUTCOME_FILE" "state" 2>/dev/null || echo "unknown")"
            if [[ "$exit_code" == "0" && "$outcome_state" == "success" ]]; then
                verified_claims=$((verified_claims + 1))
                claim_verified=true
            fi
        fi
        
        if [[ "$claim_verified" == false ]]; then
            missing_claims="${missing_claims}${missing_claims:+,}$line"
        fi
    done < <(grep -iE "$(IFS='|'; echo "${claim_patterns[*]}")" "$signoff_file" 2>/dev/null || true)
    
    if [[ "$verified_claims" -lt "$total_claims" ]]; then
        passed=false
        reason_code="unverified_claims"
    fi
    
    printf '%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$verified_claims" "$total_claims" "$missing_claims"
}

evidence_gate_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "evidence-gate requires --beads" >&2; exit 2; }
    [[ -n "$EVIDENCE_SIGNOFF_FILE" ]] || { echo "evidence-gate requires --signoff-file" >&2; exit 2; }
    
    local result gate_pass gate_reason gate_verified gate_total gate_missing
    result="$(evidence_gate_eval "$BEADS" "$EVIDENCE_SIGNOFF_FILE")"
    IFS='|' read -r gate_pass gate_reason gate_verified gate_total gate_missing <<< "$result"
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","verified_claims":%s,"total_claims":%s,"missing_claims":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_verified" "$gate_total" "$(json_escape "$gate_missing")"
    else
        echo "Evidence Gate: $gate_pass ($gate_reason)"
        echo "  Verified: $gate_verified / $gate_total claims"
        [[ -n "$gate_missing" ]] && echo "  Missing Evidence: $gate_missing"
    fi
    
    if [[ "$gate_pass" != "true" ]]; then
        exit 30
    fi
}

# ============================================================================
# PROFILES COMMAND (bd-8wdg.1)
# ============================================================================

profiles_cmd() {
    local list_only=false
    local show_profile=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --list) list_only=true; shift ;;
            --show) show_profile="${2:-}"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    if [[ -n "$show_profile" ]]; then
        show_profile "$show_profile"
        return $?
    fi
    
    echo "Available profiles:"
    list_profiles || echo "  (no profiles found)"
}

finalize_cmd() {
    parse_common_args "$@"
    [[ -n "$BEADS" ]] || { echo "finalize requires --beads" >&2; exit 2; }
    
    local provider
    provider="$(find_provider_for_beads "$BEADS")" || true
    
    if [[ -z "$provider" ]]; then
        echo "finalize failed: no job metadata found for beads=$BEADS" >&2
        exit 1
    fi
    
    job_paths "$BEADS" "$provider"
    
    if [[ ! -f "$META_FILE" ]]; then
        echo "finalize failed: no metadata file for beads=$BEADS provider=$provider" >&2
        exit 1
    fi
    
    local reason_code="${REASON_CODE:-forced_finalization}"
    local exit_code="${EXIT_CODE:-1}"
    
    force_finalize_job "$BEADS" "$provider" "$reason_code" "$exit_code"
}

# ============================================================================
# BEADS INTEGRITY GATE (bd-dxhardening)
# ============================================================================

beads_gate_eval() {
    local repo_path="${1:-$(pwd)}"
    local probe_id="${2:-}"
    local do_write_probe="${3:-false}"
    
    local passed=false
    local reason_code="unknown"
    local details=""
    local db_status="unknown"
    local repo_id_db="unavailable:not_checked"
    local repo_id_local="unavailable:not_checked"
    local external_beads_repo="${BEADS_REPO_PATH:-$HOME/bd}"
    local external_beads_remote_expected="${BEADS_REPO_REMOTE_SUBSTR:-stars-end/bd}"
    local external_beads_remote_actual=""

    # 1. Local Repo ID discovery (doesn't require bd CLI)
    local beads_config="$repo_path/.beads/config"
    if [[ -f "$beads_config" ]]; then
        repo_id_local="$(grep -E "^repo_id=" "$beads_config" 2>/dev/null | cut -d= -f2 || true)"
        if [[ -z "$repo_id_local" ]]; then
            repo_id_local="unavailable:field_missing"
        fi
    else
        repo_id_local="unavailable:config_missing"
    fi
    
    # 2. Basic environment checks
    if ! command -v bd >/dev/null 2>&1; then
        reason_code="beads_unavailable"
        details="bd CLI not found in PATH"
        db_status="unavailable"
        repo_id_db="unavailable:beads_missing"
        printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
        return 1
    fi

    if [[ ! -d "$external_beads_repo/.git" ]]; then
        reason_code="beads_external_repo_missing"
        details="External Beads repo not found at $external_beads_repo"
        db_status="unavailable"
        repo_id_db="unavailable:beads_repo_missing"
        printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
        return 1
    fi

    external_beads_remote_actual="$(git -C "$external_beads_repo" remote get-url origin 2>/dev/null || true)"
    if [[ -z "$external_beads_remote_actual" || "$external_beads_remote_actual" != *"$external_beads_remote_expected"* ]]; then
        reason_code="beads_external_remote_mismatch"
        details="External Beads remote mismatch: expected '$external_beads_remote_expected', got '${external_beads_remote_actual:-<none>}'"
        db_status="error"
        repo_id_db="unavailable:remote_mismatch"
        printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
        return 1
    fi
    
    # 3. DB connectivity check
    local status_output
    if ! status_output="$(cd "$repo_path" && bd status 2>&1)"; then
        reason_code="beads_db_error"
        details="bd status failed: ${status_output:-no output}"
        db_status="error"
        repo_id_db="unavailable:db_error"
        printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
        return 1
    fi
    db_status="connected"
    
    # 4. DB Repo ID discovery
    if [[ -n "$probe_id" ]]; then
        repo_id_db="unavailable:probe_pending"
        local show_output
        if show_output="$(cd "$repo_path" && bd show "$probe_id" 2>&1)"; then
            repo_id_db="$(echo "$show_output" | grep -oE 'repo[-_]?id[=:][[:space:]]*[a-zA-Z0-9_-]+' | head -1 | sed 's/.*[=:][[:space:]]*//' || true)"
            if [[ -z "$repo_id_db" ]]; then
                repo_id_db="unavailable:field_missing"
            fi
        else
            reason_code="beads_probe_not_found"
            details="Probe ID $probe_id not found in Beads DB"
            repo_id_db="unavailable:probe_failed"
            printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
            return 1
        fi
    else
        repo_id_db="unavailable:no_probe"
    fi
    
    # 5. Consistency check
    if [[ "$repo_id_local" != "unavailable:"* && "$repo_id_db" != "unavailable:"* && "$repo_id_local" != "$repo_id_db" ]]; then
        reason_code="beads_repo_mismatch"
        details="Local repo_id=$repo_id_local does not match DB repo_id=$repo_id_db. Remediate in worktree: printf 'y\n' | bd migrate --update-repo-id"
        printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
        return 1
    fi
    
    # 6. Optional write probe
    if [[ "$do_write_probe" == "true" && -n "$probe_id" ]]; then
        local write_ts write_result
        write_ts="gate-test-$(date +%Y%m%d%H%M%S)"
        if ! write_result="$(cd "$repo_path" && bd comments add "$probe_id" "$write_ts" 2>&1)"; then
            reason_code="beads_write_blocked"
            details="Write probe failed: ${write_result:-no output}"
            printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
            return 1
        fi
        details="Write probe successful: $write_ts"
    else
        details="DB connectivity verified"
    fi
    
    passed=true
    reason_code="beads_ok"
    printf '%s|%s|%s|%s|%s|%s|%s|%s\n' "$passed" "$reason_code" "$db_status" "$repo_id_local" "$repo_id_db" "$details" "$external_beads_repo" "$external_beads_remote_actual"
    return 0
}

beads_gate_cmd() {
    parse_common_args "$@"
    
    local repo_path="${REPO:-$(pwd)}"
    
    local result gate_pass gate_reason gate_db_status gate_repo_local gate_repo_db gate_details gate_external_repo gate_external_remote
    local gate_next_action="-"
    result="$(beads_gate_eval "$repo_path" "$PROBE_ID" "$WRITE_PROBE")" || true
    IFS='|' read -r gate_pass gate_reason gate_db_status gate_repo_local gate_repo_db gate_details gate_external_repo gate_external_remote <<< "$result"
    case "$gate_reason" in
        beads_repo_mismatch) gate_next_action="run_bd_migrate_update_repo_id" ;;
        beads_external_remote_mismatch) gate_next_action="fix_beads_external_origin" ;;
        beads_external_repo_missing) gate_next_action="clone_or_restore_external_beads_repo" ;;
        beads_db_error) gate_next_action="check_beads_db_connectivity" ;;
        *) gate_next_action="-" ;;
    esac
    
    if [[ "$OUTPUT_JSON" == "true" ]]; then
        printf '{"passed":%s,"reason_code":"%s","next_action":"%s","db_status":"%s","repo_id_local":"%s","repo_id_db":"%s","external_repo":"%s","external_remote":"%s","details":"%s"}\n' \
            "$gate_pass" "$gate_reason" "$gate_next_action" "$gate_db_status" "$gate_repo_local" "$gate_repo_db" "$(json_escape "$gate_external_repo")" "$(json_escape "$gate_external_remote")" "$(json_escape "$gate_details")"
    else
        echo "Beads Gate: $gate_pass ($gate_reason)"
        echo "  DB Status: $gate_db_status"
        echo "  Local Repo ID: ${gate_repo_local:-<not detected>}"
        echo "  DB Repo ID: ${gate_repo_db:-<not checked>}"
        echo "  External Repo: ${gate_external_repo:-<not checked>}"
        echo "  External Remote: ${gate_external_remote:-<not checked>}"
        echo "  Details: $gate_details"
        [[ "$gate_next_action" != "-" ]] && echo "  Next Action: $gate_next_action"
    fi
    
    if [[ "$gate_pass" != "true" ]]; then
        exit 24
    fi
}

# ============================================================================
# MAIN
# ============================================================================

case "$CMD" in
    start) start_cmd "$@" ;;
    status) status_cmd "$@" ;;
    check) check_cmd "$@" ;;
    health) status_cmd "$@" ;;  # Alias
    logs) logs_cmd "$@" ;;
    stop) stop_cmd "$@" ;;
    restart) restart_cmd "$@" ;;
    prune) prune_cmd "$@" ;;
    report) report_cmd "$@" ;;
    preflight) preflight_cmd "$@" ;;
    probe) probe_cmd "$@" ;;
    watchdog) watchdog_cmd "$@" ;;
    finalize) finalize_cmd "$@" ;;
    beads-gate) beads_gate_cmd "$@" ;;
    baseline-gate) baseline_gate_cmd "$@" ;;
    integrity-gate) integrity_gate_cmd "$@" ;;
    feature-key-gate) feature_key_gate_cmd "$@" ;;
    evidence-gate) evidence_gate_cmd "$@" ;;
    scope-gate) scope_gate_cmd "$@" ;;
    profiles) profiles_cmd "$@" ;;
    -h|--help|help) usage; exit 0 ;;
    *) echo "Unknown command: $CMD" >&2; usage; exit 2 ;;
esac
