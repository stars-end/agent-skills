Here's the refactored solution:

## Original Code (O(n²))
```javascript
function dedupe(items) {
  const out = [];
  for (const i of items) {
    if (out.indexOf(i) === -1) {
      out.push(i);
    }
  }
  return out;
}
```

**Complexity:** O(n²) — `indexOf` is O(n) inside an O(n) loop.

## Refactored Code (O(n))
```javascript
function dedupe(items) {
  const seen = new Set();
  const out = [];
  for (const i of items) {
    if (!seen.has(i)) {
      seen.add(i);
      out.push(i);
    }
  }
  return out;
}
```

**Complexity:** O(n) — `Set.has()` and `Set.add()` are O(1) average case.

## Table-Driven Tests
```javascript
const tests = [
  {
    name: "empty array",
    input: [],
    expected: [],
  },
  {
    name: "no duplicates",
    input: [1, 2, 3],
    expected: [1, 2, 3],
  },
  {
    name: "all duplicates",
    input: [1, 1, 1, 1],
    expected: [1],
  },
  {
    name: "mixed duplicates - preserve first-seen order",
    input: [3, 1, 2, 1, 3, 4, 2],
    expected: [3, 1, 2, 4],
  },
  {
    name: "mixed types",
    input: ["a", 1, "a", 1, "b"],
    expected: ["a", 1, "b"],
  },
];

for (const { name, input, expected } of tests) {
  const result = dedupe(input);
  const pass = JSON.stringify(result) === JSON.stringify(expected);
  console.log(`${pass ? "✓" : "✗"} ${name}`);
  if (!pass) {
    console.log(`  expected: ${JSON.stringify(expected)}`);
    console.log(`  got:      ${JSON.stringify(result)}`);
  }
}
```

**Output:**
```
✓ empty array
✓ no duplicates
✓ all duplicates
✓ mixed duplicates - preserve first-seen order
✓ mixed types
```
