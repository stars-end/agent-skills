Write a Python function `compare_semver(a: str, b: str) -> int` that follows semantic version precedence (major.minor.patch, optional prerelease). Return -1/0/1. Include edge-case handling and 8 pytest-style tests. Output only code in one fenced block.
```python
import re
from typing import List, Tuple, Union

def _parse_version(v: str) -> Tuple[int, int, int, List[Union[int, str]]]:
    """Parse semver into (major, minor, patch, prerelease_parts)."""
    if not v or not isinstance(v, str):
        raise ValueError(f"Invalid version: {v!r}")
    
    v = v.strip()
    prerelease: List[Union[int, str]] = []
    
    if '-' in v:
        core, prerelease_str = v.split('-', 1)
        if not prerelease_str:
            raise ValueError(f"Empty prerelease in: {v!r}")
        for part in prerelease_str.split('.'):
            if not part:
                raise ValueError(f"Empty prerelease identifier in: {v!r}")
            if part.isdigit():
                if len(part) > 1 and part[0] == '0':
                    raise ValueError(f"Leading zero in prerelease: {part}")
                prerelease.append(int(part))
            else:
                prerelease.append(part)
    else:
        core = v
    
    parts = core.split('.')
    if len(parts) < 1 or len(parts) > 3:
        raise ValueError(f"Invalid version format: {v!r}")
    
    version_parts = []
    for i, p in enumerate(parts):
        if not p.isdigit():
            raise ValueError(f"Non-numeric version part: {p!r}")
        if len(p) > 1 and p[0] == '0':
            raise ValueError(f"Leading zero in version: {p}")
        version_parts.append(int(p))
    
    while len(version_parts) < 3:
        version_parts.append(0)
    
    return (version_parts[0], version_parts[1], version_parts[2], prerelease)

def _compare_prerelease(a: List[Union[int, str]], b: List[Union[int, str]]) -> int:
    """Compare prerelease lists. Empty list > non-empty list."""
    if not a and not b:
        return 0
    if not a:
        return 1  # no prerelease > has prerelease
    if not b:
        return -1
    
    for pa, pb in zip(a, b):
        type_a, type_b = type(pa), type(pb)
        
        if type_a == int and type_b == int:
            if pa < pb:
                return -1
            if pa > pb:
                return 1
        elif type_a == int and type_b == str:
            return -1  # numeric < alphanumeric
        elif type_a == str and type_b == int:
            return 1
        else:  # both str
            if pa < pb:
                return -1
            if pa > pb:
                return 1
    
    if len(a) < len(b):
        return -1
    if len(a) > len(b):
        return 1
    return 0

def compare_semver(a: str, b: str) -> int:
    """
    Compare two semantic version strings.
    
    Returns:
        -1 if a < b
         0 if a == b
         1 if a > b
    
    Raises:
        ValueError: If either version string is invalid.
    """
    maj_a, min_a, patch_a, pre_a = _parse_version(a)
    maj_b, min_b, patch_b, pre_b = _parse_version(b)
    
    for va, vb in [(maj_a, maj_b), (min_a, min_b), (patch_a, patch_b)]:
        if va < vb:
            return -1
        if va > vb:
            return 1
    
    return _compare_prerelease(pre_a, pre_b)

# ==================== TESTS ====================

import pytest

def test_basic_comparison():
    assert compare_semver("1.0.0", "2.0.0") == -1
    assert compare_semver("2.0.0", "1.0.0") == 1
    assert compare_semver("1.0.0", "1.0.0") == 0

def test_minor_and_patch_comparison():
    assert compare_semver("1.2.0", "1.3.0") == -1
    assert compare_semver("1.0.5", "1.0.10") == -1
    assert compare_semver("2.1.3", "2.1.3") == 0

def test_implicit_zero_parts():
    assert compare_semver("1.0", "1.0.0") == 0
    assert compare_semver("1", "1.0.0") == 0
    assert compare_semver("2", "1.9.9") == 1

def test_prerelease_lower_than_release():
    assert compare_semver("1.0.0-alpha", "1.0.0") == -1
    assert compare_semver("1.0.0", "1.0.0-alpha") == 1
    assert compare_semver("1.0.0-beta", "1.0.0-alpha") == 1

def test_prerelease_numeric_comparison():
    assert compare_semver("1.0.0-alpha.1", "1.0.0-alpha.2") == -1
    assert compare_semver("1.0.0-alpha.10", "1.0.0-alpha.2") == 1
    assert compare_semver("1.0.0-1", "1.0.0-2") == -1

def test_prerelease_alphanumeric_vs_numeric():
    assert compare_semver("1.0.0-alpha", "1.0.0-1") == 1  # alpha > 1 (numeric)
    assert compare_semver("1.0.0-1", "1.0.0-beta") == -1

def test_prerelease_length_difference():
    assert compare_semver("1.0.0-alpha", "1.0.0-alpha.1") == -1
    assert compare_semver("1.0.0-alpha.1", "1.0.0-alpha.1.1") == -1
    assert compare_semver("1.0.0-alpha.beta", "1.0.0-alpha.beta.1") == -1

def test_invalid_versions_raise():
    with pytest.raises(ValueError):
        compare_semver("", "1.0.0")
    with pytest.raises(ValueError):
        compare_semver("1.0.0-", "1.0.0")
    with pytest.raises(ValueError):
        compare_semver("01.0.0", "1.0.0")  # leading zero
    with pytest.raises(ValueError):
        compare_semver("1.0.0-alpha..1", "1.0.0")
    with pytest.raises(ValueError):
        compare_semver("1.0.0.0", "1.0.0")  # too many parts
```