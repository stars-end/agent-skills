{"run_id": "real-p1-ccglm-longtimeout-20260218T0501Z", "workflow_id": "cc_glm_headless", "system": "cc-glm", "workflow_kind": "headless", "prompt_id": "coding_ability_1", "prompt_category": "coding_ability", "prompt_title": "Implement robust semantic version comparator", "model": "glm-5", "success": true, "retry_count": 0, "startup_latency_ms": 1, "first_output_latency_ms": 64152, "completion_latency_ms": 66673, "workflow_startup_latency_ms": null, "failure_category": null, "failure_reason": null, "hint_match_ratio": 1.0, "session_id": null, "used_model_fallback": false, "job_started_at": "2026-02-18T04:59:44Z", "job_completed_at": "2026-02-18T05:00:51Z", "attempts": [{"success": true, "return_code": 0, "timed_out": false, "startup_latency_ms": 1, "first_output_latency_ms": 64152, "completion_latency_ms": 66673, "stdout": "```python\n\"\"\"Semantic version comparison following semver.org precedence rules.\"\"\"\nfrom __future__ import annotations\nimport re\nfrom typing import Tuple, List, Union\n\n\ndef _parse_semver(v: str) -> Tuple[int, int, int, List[Union[int, str]]]:\n    \"\"\"Parse semver string into (major, minor, patch, prerelease_parts).\"\"\"\n    # Handle empty or None\n    if not v:\n        return (0, 0, 0, [])\n    \n    # Normalize: strip whitespace and leading 'v'\n    v = v.strip()\n    if v.startswith('v'):\n        v = v[1:]\n    \n    # Split off prerelease (after first '-')\n    prerelease_str = \"\"\n    if '-' in v:\n        idx = v.index('-')\n        prerelease_str = v[idx + 1:]\n        v = v[:idx]\n    \n    # Parse major.minor.patch\n    parts = v.split('.')\n    if len(parts) == 0 or (len(parts) == 1 and parts[0] == ''):\n        major, minor, patch = 0, 0, 0\n    elif len(parts) == 1:\n        major = int(parts[0]) if parts[0].isdigit() else 0\n        minor, patch = 0, 0\n    elif len(parts) == 2:\n        major = int(parts[0]) if parts[0].isdigit() else 0\n        minor = int(parts[1]) if parts[1].isdigit() else 0\n        patch = 0\n    else:\n        major = int(parts[0]) if parts[0].isdigit() else 0\n        minor = int(parts[1]) if parts[1].isdigit() else 0\n        patch = int(parts[2]) if parts[2].isdigit() else 0\n    \n    # Parse prerelease identifiers (dot-separated)\n    prerelease_parts: List[Union[int, str]] = []\n    if prerelease_str:\n        for ident in prerelease_str.split('.'):\n            if ident.isdigit():\n                prerelease_parts.append(int(ident))\n            else:\n                prerelease_parts.append(ident)\n    \n    return (major, minor, patch, prerelease_parts)\n\n\ndef _compare_prerelease(a_pre: List[Union[int, str]], b_pre: List[Union[int, str]]) -> int:\n    \"\"\"\n    Compare prerelease identifiers per semver spec.\n    Empty prerelease (stable) > any prerelease.\n    \"\"\"\n    # No prerelease = stable release, which has higher precedence\n    a_stable = len(a_pre) == 0\n    b_stable = len(b_pre) == 0\n    \n    if a_stable and b_stable:\n        return 0\n    if a_stable:\n        return 1  # a is stable, b is prerelease\n    if b_stable:\n        return -1  # a is prerelease, b is stable\n    \n    # Both have prerelease: compare identifier by identifier\n    for i in range(max(len(a_pre), len(b_pre))):\n        # Shorter prerelease has lower precedence\n        if i >= len(a_pre):\n            return -1\n        if i >= len(b_pre):\n            return 1\n        \n        a_val = a_pre[i]\n        b_val = b_pre[i]\n        \n        # Numeric identifiers have lower precedence than alphanumeric\n        a_is_num = isinstance(a_val, int)\n        b_is_num = isinstance(b_val, int)\n        \n        if a_is_num and not b_is_num:\n            return -1\n        if not a_is_num and b_is_num:\n            return 1\n        \n        # Both same type: compare directly\n        if a_val < b_val:\n            return -1\n        if a_val > b_val:\n            return 1\n    \n    return 0\n\n\ndef compare_semver(a: str, b: str) -> int:\n    \"\"\"\n    Compare two semantic versions.\n    \n    Returns:\n        -1 if a < b\n         0 if a == b\n         1 if a > b\n    \n    Precedence rules (semver.org):\n        1. Major > Minor > Patch comparison\n        2. Stable releases > prereleases\n        3. Prerelease: numeric < alphanumeric, compared left-to-right\n        4. More prerelease identifiers = higher precedence (when equal up to that point)\n    \"\"\"\n    try:\n        a_major, a_minor, a_patch, a_pre = _parse_semver(a)\n        b_major, b_minor, b_patch, b_pre = _parse_semver(b)\n    except (ValueError, TypeError):\n        # Invalid input: treat as equal to avoid crashes\n        return 0\n    \n    # Compare major.minor.patch\n    if a_major != b_major:\n        return -1 if a_major < b_major else 1\n    if a_minor != b_minor:\n        return -1 if a_minor < b_minor else 1\n    if a_patch != b_patch:\n        return -1 if a_patch < b_patch else 1\n    \n    # Major/minor/patch equal: compare prerelease\n    return _compare_prerelease(a_pre, b_pre)\n\n\n# ============== Tests ==============\n\nimport pytest\n\n\ndef test_basic_comparison():\n    \"\"\"Basic major.minor.patch comparison.\"\"\"\n    assert compare_semver(\"1.0.0\", \"2.0.0\") == -1\n    assert compare_semver(\"2.0.0\", \"1.0.0\") == 1\n    assert compare_semver(\"1.0.0\", \"1.0.0\") == 0\n\n\ndef test_minor_and_patch():\n    \"\"\"Minor and patch level comparison.\"\"\"\n    assert compare_semver(\"1.2.0\", \"1.3.0\") == -1\n    assert compare_semver(\"1.0.5\", \"1.0.10\") == -1\n    assert compare_semver(\"1.10.0\", \"1.9.0\") == 1\n\n\ndef test_prerelease_vs_stable():\n    \"\"\"Stable releases have higher precedence than prereleases.\"\"\"\n    assert compare_semver(\"1.0.0-alpha\", \"1.0.0\") == -1\n    assert compare_semver(\"1.0.0\", \"1.0.0-beta\") == 1\n    assert compare_semver(\"1.0.0-rc.1\", \"1.0.0\") == -1\n\n\ndef test_prerelease_comparison():\n    \"\"\"Prerelease identifier comparison.\"\"\"\n    assert compare_semver(\"1.0.0-alpha\", \"1.0.0-beta\") == -1\n    assert compare_semver(\"1.0.0-alpha.1\", \"1.0.0-alpha.2\") == -1\n    assert compare_semver(\"1.0.0-alpha.beta\", \"1.0.0-beta\") == -1\n\n\ndef test_numeric_vs_alphanumeric():\n    \"\"\"Numeric identifiers have lower precedence than alphanumeric.\"\"\"\n    assert compare_semver(\"1.0.0-1\", \"1.0.0-alpha\") == -1\n    assert compare_semver(\"1.0.0-alpha\", \"1.0.0-1\") == 1\n\n\ndef test_prerelease_length():\n    \"\"\"More prerelease identifiers = higher when equal up to that point.\"\"\"\n    assert compare_semver(\"1.0.0-alpha\", \"1.0.0-alpha.1\") == -1\n    assert compare_semver(\"1.0.0-alpha.1\", \"1.0.0-alpha.1.1\") == -1\n\n\ndef test_edge_cases():\n    \"\"\"Handle edge cases: empty strings, partial versions, v-prefix.\"\"\"\n    assert compare_semver(\"\", \"\") == 0\n    assert compare_semver(\"1\", \"1.0.0\") == 0\n    assert compare_semver(\"v1.0.0\", \"1.0.0\") == 0\n    assert compare_semver(\"1.0\", \"1.0.0\") == 0\n\n\ndef test_real_world_versions():\n    \"\"\"Real-world version comparison scenarios.\"\"\"\n    assert compare_semver(\"2.1.0-rc.1\", \"2.1.0\") == -1\n    assert compare_semver(\"2.1.0\", \"2.1.1\") == -1\n    assert compare_semver(\"2.1.0-beta.2\", \"2.1.0-beta.10\") == -1\n    assert compare_semver(\"2.1.0-rc.1\", \"2.1.0-rc.1.build.5\") == -1\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\"])\n```\n", "stderr": "", "failure_category": null, "failure_reason": null, "hint_match_ratio": 1.0, "session_id": null, "used_model_fallback": false, "attempt": 0, "attempt_started_at": "2026-02-18T04:59:44Z", "attempt_completed_at": "2026-02-18T05:00:51Z"}]}
